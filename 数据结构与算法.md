## 第一章 复杂度分析

**复杂度分析**是算法领域的“度量衡”。如果不懂复杂度，写代码就像在黑夜里走路，不知道自己走得快还是慢。

简单来说，复杂度分析就是预估代码运行时**消耗的资源**。



### 1.1 迭代与递归

在算法中，重复执行某个任务是很常见的，它与复杂度分析息息相关。因此，在介绍时间复杂度和空间复杂度之前，我们先来了解如何在程序中实现重复执行任务，即两种基本的程序控制结构：迭代、递归。



#### 1.1.1 迭代

迭代（iteration）是一种重复执行某个任务的控制结构。在迭代中，程序会在满足一定的条件下重复执行某段代码，直到这个条件不再满足

**①For循环** 不赘述

`for` 循环是最常见的迭代形式之一，**适合在预先知道迭代次数时使用**。

以下函数基于 `for` 循环实现了求和 $1+2+...+n$，求和结果使用变量 `res` 记录。需要注意的是，Python 中 `range(a, b)` 对应的区间是“左闭右开”的(下面为java代码)，对应的遍历范围为 $a,a+1,....b-1$：

```java
/* for 循环 */
int forLoop(int n) {
    int res = 0;
    // 循环求和 1, 2, ..., n-1, n
    for (int i = 1; i <= n; i++) {
        res += i;
    }
    return res;
}
```

此求和函数的操作数量与输入数据大小 $n$成正比，或者说成“线性关系”。实际上，**时间复杂度描述的就是这个“线性关系”**。相关内容将会在下一节中详细介绍。



**②while循环**

与 `for` 循环类似，`while` 循环也是一种实现迭代的方法。在 `while` 循环中，程序每轮都会先检查条件，如果条件为真，则继续执行，否则就结束循环。

下面我们用 `while` 循环来实现$1+2+...+n$求和 ：

```java
/* while 循环 */
int whileLoop(int n) {
    int res = 0;
    int i = 1; // 初始化条件变量
    // 循环求和 1, 2, ..., n-1, n
    while (i <= n) {
        res += i;
        i++; // 更新条件变量
    }
    return res;
}
```

**`while` 循环比 `for` 循环的自由度更高**。在 `while` 循环中，我们可以自由地设计条件变量的初始化和更新步骤。

例如在以下代码中，条件变量 $i $每轮进行两次更新，这种情况就不太方便用 `for` 循环实现

```java
/* while 循环（两次更新） */
int whileLoopII(int n) {
    int res = 0;
    int i = 1; // 初始化条件变量
    // 循环求和 1, 4, 10, ...
    while (i <= n) {
        res += i;
        // 更新条件变量
        i++;
        i *= 2;
    }
    return res;
}
```

总的来说，**`for` 循环的代码更加紧凑，`while` 循环更加灵活**，两者都可以实现迭代结构。选择使用哪一个应该根据特定问题的需求来决定。



**③ 嵌套循环**

我们可以在一个循环结构内嵌套另一个循环结构，下面以 `for` 循环为例：

```java
/* 双层 for 循环 */
String nestedForLoop(int n) {
    StringBuilder res = new StringBuilder();
    // 循环 i = 1, 2, ..., n-1, n
    for (int i = 1; i <= n; i++) {
        // 循环 j = 1, 2, ..., n-1, n
        for (int j = 1; j <= n; j++) {
            res.append("(" + i + ", " + j + "), ");
        }
    }
    return res.toString();
}
```

在这种情况下，函数的操作数量与$n^2$ 成正比，或者说算法运行时间和输入数据大小$n$ 成“平方关系”。

我们可以继续添加嵌套循环，每一次嵌套都是一次“升维”，将会使时间复杂度提高至“立方关系”“四次方关系”，以此类推。



#### 1.1.2 递归

递归（recursion）是一种算法策略，通过函数调用自身来解决问题。它主要包含两个阶段。

1. **递**：程序不断深入地调用自身，通常传入更小或更简化的参数，直到达到“终止条件”。
2. **归**：触发“终止条件”后，程序从最深层的递归函数开始逐层返回，汇聚每一层的结果。

而从实现的角度看，递归代码主要包含三个要素。

1. **终止条件**：用于决定什么时候由“递”转“归”。
2. **递归调用**：对应“递”，函数调用自身，通常输入更小或更简化的参数。
3. **返回结果**：对应“归”，将当前递归层级的结果返回至上一层。

观察以下代码，我们只需调用函数 `recur(n)` ，就可以完成 $1+2+...+n$ 的计算：

```java
/* 递归 */
int recur(int n) {
    // 终止条件
    if (n == 1)
        return 1;
    // 递：递归调用
    int res = recur(n - 1);
    // 归：返回结果
    return n + res;
}
```

<img src="assets/algorithmAssets/1.recursion_sum.png" width="60%">



虽然从计算角度看，迭代与递归可以得到相同的结果，**但它们代表了两种完全不同的思考和解决问题的范式**。

- **迭代**：“自下而上”地解决问题。从最基础的步骤开始，然后不断重复或累加这些步骤，直到任务完成。
- **递归**：“自上而下”地解决问题。将原问题分解为更小的子问题，这些子问题和原问题具有相同的形式。接下来将子问题继续分解为更小的子问题，直到基本情况时停止（基本情况的解是已知的）。



以上述求和函数为例，设问题$f(n) =1+2+....+n $。

- **迭代**：在循环中模拟求和过程，从 $1$遍历到$n$ ，每轮执行求和操作，即可求得 $f(n)$。
- **递归**：将问题分解为子问题$f(n)=n+f(n-1) $，不断（递归地）分解下去，直至基本情况$f(1)=1 $时终止。



**①调用栈**

递归函数每次调用自身时，系统都会为新开启的函数分配内存，以存储局部变量、调用地址和其他信息等。这将导致两方面的结果。

- 函数的上下文数据都存储在称为“栈帧空间”的内存区域中，直至函数返回后才会被释放。因此，**递归通常比迭代更加耗费内存空间**。
- 递归调用函数会产生额外的开销。**因此递归通常比循环的时间效率更低**。



如图 2-4 所示，在触发终止条件前，同时存在 $n$个未返回的递归函数，**递归深度为**$n$ 。

<img src="assets/algorithmAssets/1.recursion_sum_depth.png" width="60%">

上图为递归调用深度,在实际中，编程语言允许的递归深度通常是有限的，过深的递归可能导致栈溢出错误。

**②尾递归**

有趣的是，**如果函数在返回前的最后一步才进行递归调用**，则该函数可以被编译器或解释器优化，使其在空间效率上与迭代相当。这种情况被称为尾递归（tail recursion）。

- **普通递归**：当函数返回到上一层级的函数后，需要继续执行代码，因此系统需要保存上一层调用的上下文。
- **尾递归**：递归调用是函数返回前的最后一个操作，这意味着函数返回到上一层级后，无须继续执行其他操作，因此系统无须保存上一层函数的上下文。











### 2. 时间复杂度 (Time Complexity)

时间复杂度并不直接计算代码运行了多少秒（因为不同电脑硬件速度不同），而是计算**随着输入数据量 $n$ 的增大，执行操作次数的增长趋势**。

我们通常使用 **大 O 表示法 (Big O Notation)**，它只关注“最高阶项”，并忽略常数。

### 常见的复杂度等级（从快到慢）

| **复杂度**    | **名称**   | **形象描述**                | **典型场景**                   |
| ------------- | ---------- | --------------------------- | ------------------------------ |
| $O(1)$        | 常数阶     | 瞬间完成                    | 访问数组下标、哈希查找         |
| $O(\log n)$   | 对数阶     | 极快（翻倍增长，步骤只加1） | **二分查找**                   |
| $O(n)$        | 线性阶     | 中规中矩                    | 遍历一次数组、简单搜索         |
| $O(n \log n)$ | 线性对数阶 | 工业级标准                  | **快速排序、归并排序**         |
| $O(n^2)$      | 平方阶     | 开始变慢                    | 冒泡排序、嵌套循环             |
| $O(2^n)$      | 指数阶     | 灾难级                      | 暴力递归、斐波那契数列简单递归 |

**如何快速判断时间复杂度？**

1. **看循环层数：** 一层循环通常是 $O(n)$，嵌套两层通常是 $O(n^2)$。
2. **看折半操作：** 如果每次循环数据量都减半（如二分法），那就是 $O(\log n)$。
3. **看递归：** 递归的时间复杂度通常等于“递归树的节点总数”。



### 3. 空间复杂度 (Space Complexity)

空间复杂度衡量的是**算法在运行过程中临时占用的存储空间大小**。

- **$O(1)$：** 无论输入多少数据，只开了几个固定变量（如 `int i, temp`）。
- **$O(n)$：** 为了处理数据，额外开辟了一个和 $n$ 一样大的数组或集合。
- **$O(n^2)$：** 比如开辟了一个二维矩阵来存储关系。

> **注意：** 面试中通常存在 **“空间换时间”** 的策略。例如哈希表（Space $O(n)$）可以将查找时间从 $O(n)$ 降到 $O(1)$。