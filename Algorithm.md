# 基础

## 简单理解

1、时空复杂度用 Big O 表示法表示（类似 O(1),O(n2),O(logn)*O*(1),*O*(*n*2),*O*(*l**o**g**n*) 等）。**它们都是估计值，不需要精确计算，常数项和低增长项都可以忽略，仅需保留最高增长项**。

比方说 O(2n2+3n+1)*O*(2*n*2+3*n*+1) 等同于 O(n2)*O*(*n*2)，O(1000n+1000)*O*(1000*n*+1000) 等同于 O(n)*O*(*n*)。

2、我们分析算法复杂度时，分析的是最坏情况的复杂度。这一点会在下面的示例中体现。

3、时间复杂度用来衡量一个算法的执行效率，空间复杂度用来衡量算法的内存消耗，它们都是越小越好。

比方说时间复杂度 O(n)*O*(*n*) 的算法比 O(n2)*O*(*n*2) 的算法执行效率高，空间复杂度 O(1)*O*(1) 的算法比 O(n)*O*(*n*) 的算法内存消耗小。

当然，一般我们要说明这个 n*n* 代表什么，比如 n*n* 代表输入的数组的长度。

4、如何估算？**现在你可以简单理解：时间复杂度大部分情况下就是看 for 循环的最大嵌套层数；空间复杂度就看算法申请了多少空间来存储数据**



## 时间/空间复杂度案例分析

**示例一，时间复杂度 $O(n)$，空间复杂度 $O(1)\$**：

```java
// 输入一个整数数组，返回所有元素的和
int getSum(int[] nums) {
    int sum = 0;
    for (int i = 0; i < nums.length; i++) {
        sum += nums[i];
    }
    return sum;
}
```

算法包含一个 for 循环遍历 `nums` 数组，所以时间复杂度是$ O(n)$，其中 `n` 代表 `nums` 数组的长度。

我们的算法只使用了一个 `sum` 变量，这个 `nums` 是题目给的输入，不算在我们算法的空间复杂度里面，所以空间复杂度是 $ O(1)$。



**示例二，时间复杂度 $O(n)$，空间复杂度 $O(1)$**：

```java
// 当 n 是 10 的倍数时，计算累加和，否则返回 -1
int sum(int n) {
    if (n % 10 != 0) {
        return -1;
    }
    int sum = 0;
    for (int i = 0; i <= n; i++) {
        sum += i;
    }
    return sum;
}
```

其实只有当 `n` 是 10 的倍数时，算法才会执行 for 循环，时间复杂度是 $O(n)$。其他情况下算法会直接返回，时间复杂度是 $O(1)$。

但是算法复杂度只考察最坏情况，所以这个算法的时间复杂度是 $O(n)$，空间复杂度是 $O(1)$。



**示例三，时间复杂度 $O(n^2)$，空间复杂度 $O(1)$**：

```java
// 数组是否存在两个数，它们的和为 target？
boolean hasTargetSum(int[] nums, int target) {
    for (int i = 0; i < nums.length; i++) {
        for (int j = i + 1; j < nums.length; j++) {
            if (nums[i] + nums[j] == target) {
                return true;
            }
        }
    }
    return false;
}
```

算法嵌套了两层 for 循环，所以时间复杂度是 $O(n^2)$，其中 $n$ 代表 `nums` 数组的长度。

我们的算法只使用了 `i, j` 两个变量，这是常数级别的空间消耗，所以空间复杂度是 O(1)*O*(1)。

你也许会说，内层的 for 循环并没有遍历整个数组，且有可能提前 return，算法实际执行的次数应该是小于$ n^2$ 的，时间复杂度还是 $O(n^2)$吗？

是的，还是 $O(n^2)$。具体到不同的输入，算法的实际执行次数确实会小于 $O(n^2)$，但我们不需要关心这些细节，估算一个最坏情况的时间复杂度就可以了。

每层 for 循环在最坏情况下都是 $O(n)$ 的时间复杂度，套在一起，总的时间复杂度是 $O(n^2)$。



**示例四，时间复杂度 $O(n)$，空间复杂度 $O(n)$**：

```java
void exampleFn(int n) {
    int[] nums = new int[n];
}
```

这个函数中创建了一个大小为 `n` 的数组，所以空间复杂度是 $O(n)$。	

上述代码申请数组空间并将 `n` 个元素初始化为 0。内存申请操作的时间复杂度可以认为是  $O(n)$，但为所有元素赋值的操作相当于一个隐藏的 for 循环（由编程语言为我们自动完成），时间复杂度是  $O(n)$。所以总的时间复杂度是  $O(n)$。

时间复杂度并不仅仅体现在你看得到的 for 循环，每一行代码都可能有隐藏的时间复杂度。所以说要了解编程语言提供的常用数据结构实现原理，这是准确分析时间复杂度的基础。



**示例五，时间复杂度 $O(n)$，空间复杂度 $O(n)$**：

```Java
// 输入一个整数数组，返回一个新的数组，新数组的每个元素是原数组对应元素的平方
int[] squareArray(int[] nums) {
    int[] res = new int[nums.length];
    for (int i = 0; i < nums.length; i++) {
        res[i] = nums[i] * nums[i];
    }
    return res;
}
```

算法初始化 `res` 数组需要 $O(n)$ 的时间复杂度，包含一个 for 循环，时间复杂度也是 $O(n)$，总的时间复杂度是还是 $O(n)$ 其中 `n` 代表 `nums` 数组的长度。

我们声明了一个新的数组 `res`，这个数组的长度和 `nums` 数组一样，所以空间复杂度是 O(n)*O*(*n*)。

好了，初学者明白上面这些基本的时间、空间复杂度分析暂时就够用了，继续往下学习吧。



## 数组/动态数组

静态数组在创建的时候就要确定数组的元素类型和元素数量。只有在 C++、Java、Golang 这类语言中才提供了创建静态数组的方式，类似 Python、JavaScript 这类语言并没有提供静态数组的定义方式。

静态数组的用法比较原始，实际软件开发中很少用到，写算法题也没必要用，我们一般直接用动态数组。但为了理解原理，在这里还是要讲解一下。

定义一个静态数组的方法如下：

```java
// 定义一个大小为 10 的静态数组
int[] arr = new int[10];

// 使用索引赋值
arr[0] = 1;
arr[1] = 2;

// 使用索引取值
int a = arr[0];
```



就这，没有其他什么操作了。

拿 C++ 来举例吧，`int arr[10]` 这段代码到底做了什么事情呢？主要有这么几件事：

1、在内存中开辟了一段**连续的内存空间**，大小是 `10 * sizeof(int)` 字节。一个 int 在计算机内存中占 4 字节，也就是总共 40 字节。

2、定义了一个名为 `arr` 的数组指针，指向这段内存空间的首地址。

那么 `arr[1] = 2` 这段代码又做了什么事情呢？主要有这么几件事：

1、计算 `arr` 的首地址加上 `1 * sizeof(int)` 字节（4 字节）的偏移量，找到了内存空间中的第二个元素的**首地址**。

2、从这个地址开始的 4 个字节的内存空间中写入了整数 `2`。

> 写给初学者
>
> 我记得以前刚上大学的时候要学 C 语言基础，有些同学就绕不清楚什么指针的数组，数组的指针，绕来绕去的。其实只要明白了上面这个简单的流程，一切就很清楚了。
>
> 1、为什么数组的索引从 0 开始？就是方便取地址。`arr[0]` 就是 `arr` 的首地址，从这个地址往后的 4 个字节存储着第一个元素的值；`arr[1]` 就是 `arr` 的首地址加上 `1 * 4` 字节，也就是第二个元素的首地址，这个地址往后的 4 个字节存储着第二个元素的值。`arr[2], arr[3]` 以此类推。
>
> 2、因为数组的名字 `arr` 就指向整块内存的首地址，所以数组名 `arr` 就是一个指针。你直接取这个地址的值，就是第一个元素的值。也就是说，`*arr` 的值就是 `arr[0]`，即第一个元素的值。
>
> 3、如果不用 `memset` 这种函数初始化数组的值，那么数组内的值是不确定的。因为 `int arr[10]` 这个语句只是请操作系统在内存中开辟了一块连续的内存空间，你也不知道这块空间是谁使用过的二手内存，你也不知道里面存了什么奇奇怪怪的东西。所以一般我们会用 `memset` 函数把这块内存空间的值初始化一下再使用。
>
> 当然，上面讲的这些内容都是针对 C/C++，因为大家学习计算机基础的时候都接触过。其他比如 Java Golang 这种语言，静态数组创建出来后会自动帮你把元素值都初始化为 0，所以不需要再显式进行初始化。

我梳理一下上面的因果逻辑，静态数组本质上就是一块**连续的**内存空间，`int arr[10]` 这个语句我们可以得知：

1、我们知道这块内存空间的首地址（数组名 `arr` 就指向这块内存空间的首地址）。

2、我们知道了每个元素的类型（比如 int），也就是知道了每个元素占用的内存空间大小（比如一个 int 占 4 字节，32 bit）。

3、这块内存空间是连续的，其大小为 `10 * sizeof(int)` 即 40 字节。

**所以，我们获得了数组的超能力「随机访问」：只要给定任何一个数组索引，我可以在 $O(1)$ 的时间内直接获取到对应元素的值**。

因为我可以通过首地址和索引直接计算出目标元素的内存地址。计算机的内存寻址时间可以认为是 $O(1)$，所以数组的随机访问时间复杂度是 $O(1)$。

但是，一个人最大的优势往往也是他的最大劣势。数组连续内存的特性给了他随机访问的超能力，但它也因此吃了不少苦，下面介绍。



### 增删查改

**数据结构的职责就是增删查改**，再无其他。

那么刚刚介绍数组这种数据结构的底层原理，我们其实只介绍了「查」和「改」的部分，也就是通过索引修改和访问对应元素的值。那么「增删」这两个操作又是如何实现的呢？



#### 增

要想给静态数组增加元素，这就有些复杂了，需要分情况讨论。

**情况一，数组末尾追加（append）元素**

比方说，我有一个大小为 10 的数组，里面装了 4 个元素，现在想在末尾追加一个元素，怎么办？

比较简单，直接在对应的索引赋值就行了，这是大概的代码逻辑：

```java
// 大小为 10 的数组已经装了 4 个元素
int[] arr = new int[10];
for (int i = 0; i < 4; i++) {
    arr[i] = i;
}

// 现在想在数组末尾追加一个元素 4
arr[4] = 4;

// 再在数组末尾追加一个元素 5
arr[5] = 5;

// 依此类推
// ...
```

**可以看到，由于只是对索引赋值，所以在数组末尾追加元素的时间复杂度是 O(1)\*O\*(1)**。

情况二，数组中间插入（insert）元素

比方说，我有一个大小为 10 的数组 `arr`，前 4 个位置装了元素，现在想在第 3 个位置（索引 2 `arr[2]`）插入一个新元素，怎么办？

这就要涉及「数据搬移」，给新元素腾出空位，然后再才能插入新元素。大概的代码逻辑是这样的：

```java
// 大小为 10 的数组已经装了 4 个元素
int[] arr = new int[10];
for (int i = 0; i < 4; i++) {
    arr[i] = i;
}

// 在索引 2 置插入元素 666
// 需要把索引 2 以及之后的元素都往后移动一位
// 注意要倒着遍历数组中已有元素避免覆盖，不懂的话请看下方可视化面板
for (int i = 4; i > 2; i--) {
    arr[i] = arr[i - 1];
}

// 现在第 3 个位置空出来了，可以插入新元素
arr[2] = 666;
```

**综上，在数组中间插入元素的时间复杂度是 $O(N)$，因为涉及到数据搬移，给新元素腾地方**



情况三，数组空间已满

静态数组在创建时就要确定大小，比方说现在我创建了一个数组 `int arr[10]`（一块 40 字节的连续内存空间），然后往里面存了 10 个元素，这时候我想再插入一个元素，怎么办？无论是追加在尾部还是插入到中间，都没有位置留给新元素了。

有的读者可能说，这个简单呀，在这 40 字节后面再加上 4 个字节的连续内存空间，用来存储新的元素，不就行了吗？

**不行的，连续内存必须一次性分配，分配完了之后就不能随意增减了**。因为你这块连续内存后面的内存空间可能已经被其他程序占用了，不能说你想要就给你。

那怎么办呢？只能重新申请一块更大的内存空间，把原来的数据复制过去，再插入新的元素，这就是数组的「扩容」操作。

比方说，我重新创建一个更大的数组 `int arr[20]`，然后把原来的 10 个元素复制过去，这样就有空余位置插入新的元素了。

大概的逻辑是这样的：

```java
// 大小为 10 的数组已经装满了
int[] arr = new int[10];
for (int i = 0; i < 10; i++) {
    arr[i] = i;
}

// 现在想在数组末尾追加一个元素 10
// 需要先扩容数组
int[] newArr = new int[20];
// 把原来的 10 个元素复制过去
for (int i = 0; i < 10; i++) {
    newArr[i] = arr[i];
}

// 旧数组的内存空间将由垃圾收集器处理
// ...

// 在新的大数组中追加新元素
newArr[10] = 10;
```

**综上，数组的扩容操作会涉及到新数组的开辟和数据的复制，时间复杂度是 $O(N)$。**



#### 删

删除元素的操作和增加元素的操作类似，也需要分情况讨论。

**情况一，删除末尾元素**

比方说，我有一个大小为 10 的数组，里面装了 5 个元素，现在想删除末尾的元素，怎么办？

很简单，直接把末尾元素标记为一个特殊值代表已删除就行了，我们这里简单举例，就用 -1 作为特殊值代表已删除好了。后面带大家具体实现动态数组的时候，会有更完善的方法删除数组元素，这里只是为了说明删除数组尾部元素的本质就是进行一次随机访问，时间复杂度是 $O(1)$。

大概的代码逻辑是这样的：

```java
// 大小为 10 的数组已经装了 5 个元素
int[] arr = new int[10];
for (int i = 0; i < 5; i++) {
    arr[i] = i;
}

// 删除末尾元素，暂时用 -1 代表元素已删除
arr[4] = -1;
```



**情况二，删除中间元素**

比方说，我有一个大小为 10 的数组，里面装了 5 个元素，现在想删除第 2 个元素（`arr[1]`），怎么办？

这也要涉及「数据搬移」，把被删元素后面的元素都往前移动一位，保持数组元素的连续性。

大概的代码逻辑是这样的：

```java
// 大小为 10 的数组已经装了 5 个元素
int[] arr = new int[10];
for (int i = 0; i < 5; i++) {
    arr[i] = i;
}

// 删除 arr[1]
// 需要把 arr[1] 之后的元素都往前移动一位
// 注意要正着遍历数组中已有元素避免覆盖，不懂的话请看下方可视化面板
for (int i = 1; i < 4; i++) {
    arr[i] = arr[i + 1];
}

// 最后一个元素置为 -1 代表已删除
arr[4] = -1;
```



**综上，在数组中间删除元素的时间复杂度是 $O(N)$，因为涉及到数据搬移**。



### 动态数组

刚才讲了静态数组的超能力和种种局限性，现在讲动态数组，动态数组是静态数组的强化版，也是我们在实际软件开发或者写算法题时最常用的数据结构之一。

首先，你不要以为动态数组可以解决静态数组在中间增删元素效率差的问题，不可能解决的。数组随机访问的超能力源于数组连续的内存空间，而连续的内存空间就不可避免地面对数据搬移和扩缩容的问题。

**动态数组底层还是静态数组，只是自动帮我们进行数组空间的扩缩容，并把增删查改操作进行了封装，让我们使用起来更方便而已**。

简单列举一下各个语言的动态数组使用方法：

```java
// 创建动态数组
// 不用显式指定数组大小，它会根据实际存储的元素数量自动扩缩容
ArrayList<Integer> arr = new ArrayList<>();

for (int i = 0; i < 10; i++) {
    // 在末尾追加元素，时间复杂度 O(1)
    arr.add(i);
}

// 在中间插入元素，时间复杂度 O(N)
// 在索引 2 的位置插入元素 666
arr.add(2, 666);

// 在头部插入元素，时间复杂度 O(N)
arr.add(0, -1);

// 删除末尾元素，时间复杂度 O(1)
arr.remove(arr.size() - 1);

// 删除中间元素，时间复杂度 O(N)
// 删除索引 2 的元素
arr.remove(2);

// 根据索引查询元素，时间复杂度 O(1)
int a = arr.get(0);

// 根据索引修改元素，时间复杂度 O(1)
arr.set(0, 100);

// 根据元素值查找索引，时间复杂度 O(N)
int index = arr.indexOf(666);
```

在后面的章节，我会手把手带大家实现一个动态数组，让大家更加深入地理解动态数组的原理。



### 链表（链式存储）基本原理

#### 1.定义

如果说**数组**是一排**排好号的电影院座位**（位置固定且连在一起），那么**链表**就是一场**全城范围的寻宝游戏**。

链表（linked list）是一种线性数据结构，其中的每个元素都是一个节点对象，各个节点通过“引用”相连接。引用记录了下一个节点的内存地址，通过它可以从当前节点访问到下一个节点。



链表的“人话”定义:

在链表里，数据不是排排坐的。每个数据（我们叫它**节点 Node**）都住在内存的一个随机角落里。

为了能找到彼此，每个节点手里都拽着一张小纸条，上面写着：**“下一个人的地址在哪里”**。

一个典型的节点包含两部分：

1. **数据域 (Data)：** 存你的宝贝（数字、字符串等）。
2. **指针域 (Next)：** 指向下一个节点的内存地址。

![2.linkedlist_definition](assets/algorithmAssets/2.linkedlist_definition.png)

观察上图:链表的组成单位是节点（node）对象。每个节点都包含两项数据：节点的“值”和指向下一节点的“引用”。

- 链表的首个节点被称为“头节点”，最后一个节点被称为“尾节点”。
- 尾节点指向的是“空”，它在 Java、C++ 和 Python 中分别被记为 `null`、`nullptr` 和 `None` 。
- 在 C、C++、Go 和 Rust 等支持指针的语言中，上述“引用”应被替换为“指针”。





#### **2.链表家族**

1. **单链表：** 只有 `Next` 指针。就像单行道，只能往前走，回不了头。
2. **双链表：** 每个节点既有 `Next` 也有 `Prev`（指向前一个）。就像双向车道，虽然费点内存，但更灵活。
3. **循环链表：** 最后一个人的 `Next` 指向了第一个人。像个圆环（常用于解决“约瑟夫环”问题或轮询调度）。



刷过力扣的读者肯定对单链表非常熟悉，力扣上的单链表节点定义如下：

```java
class ListNode {
    int val;
    ListNode next;
    ListNode(int x) { val = x; }
}
```

这仅仅是一个最简单的**单链表节点**，方便力扣出算法题来考你。在实际的编程语言中，我们使用的链表节点会稍微复杂一点，类似这样：

```java
class Node<E> {
    E val;
    Node<E> next;
    Node<E> prev;

    Node(Node<E> prev, E element, Node<E> next) {
        this.val = element;
        this.next = next;
        this.prev = prev;
    }
}
```

主要区别有两个：

1、编程语言标准库一般都会提供泛型，即你可以指定 `val` 字段为任意类型，而力扣的单链表节点的 `val` 字段只有 int 类型。

2、编程语言标准库一般使用的都是双链表而非单链表。单链表节点只有一个 `next` 指针，指向下一个节点；而双链表节点有两个指针，`prev` 指向前一个节点，`next` 指向下一个节点。

有了 `prev` 前驱指针，链表支持双向遍历，但由于要多维护一个指针，增删查改时会稍微复杂一些，后面带大家实现双链表时会具体介绍。



#### 3.为什么要发明链表？

数组不是挺好吗？

前面介绍了 [数组（顺序存储）的底层原理](https://labuladong.online/zh/algo/data-structure-basic/array-basic/)，说白了就是一块连续的内存空间，有了这块内存空间的首地址，就能直接通过索引计算出任意位置的元素地址。

链表不一样，一条链表并不需要一整块连续的内存空间存储元素。链表的元素可以分散在内存空间的天涯海角，通过每个节点上的 `next, prev` 指针，将零散的内存块串联起来形成一个链式结构。

这样做的好处很明显，首先就是可以提高内存的利用效率，链表的节点不需要挨在一起，给点内存 new 出来一个节点就能用，操作系统会觉得这娃好养活。

另外一个好处，它的节点要用的时候就能接上，不用的时候拆掉就行了，从来不需要考虑扩缩容和数据搬移的问题，理论上讲，链表是没有容量限制的（除非把所有内存都占满，这不太可能）。

当然，不可能只有好处没有局限性。数组最大的优势是支持通过索引快速访问元素，而链表就不支持。

这个不难理解吧，因为元素并不是紧挨着的，所以如果你想要访问第 3 个链表元素，你就只能从头结点开始往顺着 `next` 指针往后找，直到找到第 3 个节点才行。

上面是对链表这种数据结构的基本介绍，接下来我们就结合代码实现单/双链表的几个基本操作。



> 附上数组和链表的对比

| **特性**            | **数组 (Array)**              | **链表 (Linked List)**      | **谁赢了？** |
| ------------------- | ----------------------------- | --------------------------- | ------------ |
| **找第 i 个元素**   | 瞬间找到 ($O(1)$)             | 得从头一个一个数 ($O(n)$)   | **数组**     |
| **在中间插入/删除** | 后面所有人都要挪位置 ($O(n)$) | 只要把“纸条”改一下 ($O(1)$) | **链表**     |
| **内存分配**        | 必须提前要一块连续的大地盘    | 随用随申请，哪里有空住哪里  | **链表**     |



#### 4.单链表的基本操作

我先写一个工具函数，用于创建一条单链表，方便后面的讲解：

