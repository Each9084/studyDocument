# 基础

## 简单理解

1、时空复杂度用 Big O 表示法表示（类似 O(1),O(n2),O(logn)*O*(1),*O*(*n*2),*O*(*l**o**g**n*) 等）。**它们都是估计值，不需要精确计算，常数项和低增长项都可以忽略，仅需保留最高增长项**。

比方说 O(2n2+3n+1)*O*(2*n*2+3*n*+1) 等同于 O(n2)*O*(*n*2)，O(1000n+1000)*O*(1000*n*+1000) 等同于 O(n)*O*(*n*)。

2、我们分析算法复杂度时，分析的是最坏情况的复杂度。这一点会在下面的示例中体现。

3、时间复杂度用来衡量一个算法的执行效率，空间复杂度用来衡量算法的内存消耗，它们都是越小越好。

比方说时间复杂度 O(n)*O*(*n*) 的算法比 O(n2)*O*(*n*2) 的算法执行效率高，空间复杂度 O(1)*O*(1) 的算法比 O(n)*O*(*n*) 的算法内存消耗小。

当然，一般我们要说明这个 n*n* 代表什么，比如 n*n* 代表输入的数组的长度。

4、如何估算？**现在你可以简单理解：时间复杂度大部分情况下就是看 for 循环的最大嵌套层数；空间复杂度就看算法申请了多少空间来存储数据**



## 时间/空间复杂度案例分析

**示例一，时间复杂度 $O(n)$，空间复杂度 $O(1)\$**：

```java
// 输入一个整数数组，返回所有元素的和
int getSum(int[] nums) {
    int sum = 0;
    for (int i = 0; i < nums.length; i++) {
        sum += nums[i];
    }
    return sum;
}
```

算法包含一个 for 循环遍历 `nums` 数组，所以时间复杂度是$ O(n)$，其中 `n` 代表 `nums` 数组的长度。

我们的算法只使用了一个 `sum` 变量，这个 `nums` 是题目给的输入，不算在我们算法的空间复杂度里面，所以空间复杂度是 $ O(1)$。



**示例二，时间复杂度 $O(n)$，空间复杂度 $O(1)$**：

```java
// 当 n 是 10 的倍数时，计算累加和，否则返回 -1
int sum(int n) {
    if (n % 10 != 0) {
        return -1;
    }
    int sum = 0;
    for (int i = 0; i <= n; i++) {
        sum += i;
    }
    return sum;
}
```

其实只有当 `n` 是 10 的倍数时，算法才会执行 for 循环，时间复杂度是 $O(n)$。其他情况下算法会直接返回，时间复杂度是 $O(1)$。

但是算法复杂度只考察最坏情况，所以这个算法的时间复杂度是 $O(n)$，空间复杂度是 $O(1)$。



**示例三，时间复杂度 $O(n^2)$，空间复杂度 $O(1)$**：

```java
// 数组是否存在两个数，它们的和为 target？
boolean hasTargetSum(int[] nums, int target) {
    for (int i = 0; i < nums.length; i++) {
        for (int j = i + 1; j < nums.length; j++) {
            if (nums[i] + nums[j] == target) {
                return true;
            }
        }
    }
    return false;
}
```

算法嵌套了两层 for 循环，所以时间复杂度是 $O(n^2)$，其中 $n$ 代表 `nums` 数组的长度。

我们的算法只使用了 `i, j` 两个变量，这是常数级别的空间消耗，所以空间复杂度是 O(1)*O*(1)。

你也许会说，内层的 for 循环并没有遍历整个数组，且有可能提前 return，算法实际执行的次数应该是小于$ n^2$ 的，时间复杂度还是 $O(n^2)$吗？

是的，还是 $O(n^2)$。具体到不同的输入，算法的实际执行次数确实会小于 $O(n^2)$，但我们不需要关心这些细节，估算一个最坏情况的时间复杂度就可以了。

每层 for 循环在最坏情况下都是 $O(n)$ 的时间复杂度，套在一起，总的时间复杂度是 $O(n^2)$。



**示例四，时间复杂度 $O(n)$，空间复杂度 $O(n)$**：

```java
void exampleFn(int n) {
    int[] nums = new int[n];
}
```

这个函数中创建了一个大小为 `n` 的数组，所以空间复杂度是 $O(n)$。	

上述代码申请数组空间并将 `n` 个元素初始化为 0。内存申请操作的时间复杂度可以认为是  $O(n)$，但为所有元素赋值的操作相当于一个隐藏的 for 循环（由编程语言为我们自动完成），时间复杂度是  $O(n)$。所以总的时间复杂度是  $O(n)$。

时间复杂度并不仅仅体现在你看得到的 for 循环，每一行代码都可能有隐藏的时间复杂度。所以说要了解编程语言提供的常用数据结构实现原理，这是准确分析时间复杂度的基础。



**示例五，时间复杂度 $O(n)$，空间复杂度 $O(n)$**：

```Java
// 输入一个整数数组，返回一个新的数组，新数组的每个元素是原数组对应元素的平方
int[] squareArray(int[] nums) {
    int[] res = new int[nums.length];
    for (int i = 0; i < nums.length; i++) {
        res[i] = nums[i] * nums[i];
    }
    return res;
}
```

算法初始化 `res` 数组需要 $O(n)$ 的时间复杂度，包含一个 for 循环，时间复杂度也是 $O(n)$，总的时间复杂度是还是 $O(n)$ 其中 `n` 代表 `nums` 数组的长度。

我们声明了一个新的数组 `res`，这个数组的长度和 `nums` 数组一样，所以空间复杂度是 O(n)*O*(*n*)。

好了，初学者明白上面这些基本的时间、空间复杂度分析暂时就够用了，继续往下学习吧。



## 数组/动态数组

静态数组在创建的时候就要确定数组的元素类型和元素数量。只有在 C++、Java、Golang 这类语言中才提供了创建静态数组的方式，类似 Python、JavaScript 这类语言并没有提供静态数组的定义方式。

静态数组的用法比较原始，实际软件开发中很少用到，写算法题也没必要用，我们一般直接用动态数组。但为了理解原理，在这里还是要讲解一下。

定义一个静态数组的方法如下：

```java
// 定义一个大小为 10 的静态数组
int[] arr = new int[10];

// 使用索引赋值
arr[0] = 1;
arr[1] = 2;

// 使用索引取值
int a = arr[0];
```



就这，没有其他什么操作了。

拿 C++ 来举例吧，`int arr[10]` 这段代码到底做了什么事情呢？主要有这么几件事：

1、在内存中开辟了一段**连续的内存空间**，大小是 `10 * sizeof(int)` 字节。一个 int 在计算机内存中占 4 字节，也就是总共 40 字节。

2、定义了一个名为 `arr` 的数组指针，指向这段内存空间的首地址。

那么 `arr[1] = 2` 这段代码又做了什么事情呢？主要有这么几件事：

1、计算 `arr` 的首地址加上 `1 * sizeof(int)` 字节（4 字节）的偏移量，找到了内存空间中的第二个元素的**首地址**。

2、从这个地址开始的 4 个字节的内存空间中写入了整数 `2`。

> 写给初学者
>
> 我记得以前刚上大学的时候要学 C 语言基础，有些同学就绕不清楚什么指针的数组，数组的指针，绕来绕去的。其实只要明白了上面这个简单的流程，一切就很清楚了。
>
> 1、为什么数组的索引从 0 开始？就是方便取地址。`arr[0]` 就是 `arr` 的首地址，从这个地址往后的 4 个字节存储着第一个元素的值；`arr[1]` 就是 `arr` 的首地址加上 `1 * 4` 字节，也就是第二个元素的首地址，这个地址往后的 4 个字节存储着第二个元素的值。`arr[2], arr[3]` 以此类推。
>
> 2、因为数组的名字 `arr` 就指向整块内存的首地址，所以数组名 `arr` 就是一个指针。你直接取这个地址的值，就是第一个元素的值。也就是说，`*arr` 的值就是 `arr[0]`，即第一个元素的值。
>
> 3、如果不用 `memset` 这种函数初始化数组的值，那么数组内的值是不确定的。因为 `int arr[10]` 这个语句只是请操作系统在内存中开辟了一块连续的内存空间，你也不知道这块空间是谁使用过的二手内存，你也不知道里面存了什么奇奇怪怪的东西。所以一般我们会用 `memset` 函数把这块内存空间的值初始化一下再使用。
>
> 当然，上面讲的这些内容都是针对 C/C++，因为大家学习计算机基础的时候都接触过。其他比如 Java Golang 这种语言，静态数组创建出来后会自动帮你把元素值都初始化为 0，所以不需要再显式进行初始化。

我梳理一下上面的因果逻辑，静态数组本质上就是一块**连续的**内存空间，`int arr[10]` 这个语句我们可以得知：

1、我们知道这块内存空间的首地址（数组名 `arr` 就指向这块内存空间的首地址）。

2、我们知道了每个元素的类型（比如 int），也就是知道了每个元素占用的内存空间大小（比如一个 int 占 4 字节，32 bit）。

3、这块内存空间是连续的，其大小为 `10 * sizeof(int)` 即 40 字节。

**所以，我们获得了数组的超能力「随机访问」：只要给定任何一个数组索引，我可以在 $O(1)$ 的时间内直接获取到对应元素的值**。

因为我可以通过首地址和索引直接计算出目标元素的内存地址。计算机的内存寻址时间可以认为是 $O(1)$，所以数组的随机访问时间复杂度是 $O(1)$。

但是，一个人最大的优势往往也是他的最大劣势。数组连续内存的特性给了他随机访问的超能力，但它也因此吃了不少苦，下面介绍。



### 增删查改

**数据结构的职责就是增删查改**，再无其他。

那么刚刚介绍数组这种数据结构的底层原理，我们其实只介绍了「查」和「改」的部分，也就是通过索引修改和访问对应元素的值。那么「增删」这两个操作又是如何实现的呢？



#### 增

要想给静态数组增加元素，这就有些复杂了，需要分情况讨论。

**情况一，数组末尾追加（append）元素**

比方说，我有一个大小为 10 的数组，里面装了 4 个元素，现在想在末尾追加一个元素，怎么办？

比较简单，直接在对应的索引赋值就行了，这是大概的代码逻辑：

```java
// 大小为 10 的数组已经装了 4 个元素
int[] arr = new int[10];
for (int i = 0; i < 4; i++) {
    arr[i] = i;
}

// 现在想在数组末尾追加一个元素 4
arr[4] = 4;

// 再在数组末尾追加一个元素 5
arr[5] = 5;

// 依此类推
// ...
```

**可以看到，由于只是对索引赋值，所以在数组末尾追加元素的时间复杂度是 O(1)\*O\*(1)**。

情况二，数组中间插入（insert）元素

比方说，我有一个大小为 10 的数组 `arr`，前 4 个位置装了元素，现在想在第 3 个位置（索引 2 `arr[2]`）插入一个新元素，怎么办？

这就要涉及「数据搬移」，给新元素腾出空位，然后再才能插入新元素。大概的代码逻辑是这样的：

```java
// 大小为 10 的数组已经装了 4 个元素
int[] arr = new int[10];
for (int i = 0; i < 4; i++) {
    arr[i] = i;
}

// 在索引 2 置插入元素 666
// 需要把索引 2 以及之后的元素都往后移动一位
// 注意要倒着遍历数组中已有元素避免覆盖，不懂的话请看下方可视化面板
for (int i = 4; i > 2; i--) {
    arr[i] = arr[i - 1];
}

// 现在第 3 个位置空出来了，可以插入新元素
arr[2] = 666;
```

**综上，在数组中间插入元素的时间复杂度是 $O(N)$，因为涉及到数据搬移，给新元素腾地方**



情况三，数组空间已满

静态数组在创建时就要确定大小，比方说现在我创建了一个数组 `int arr[10]`（一块 40 字节的连续内存空间），然后往里面存了 10 个元素，这时候我想再插入一个元素，怎么办？无论是追加在尾部还是插入到中间，都没有位置留给新元素了。

有的读者可能说，这个简单呀，在这 40 字节后面再加上 4 个字节的连续内存空间，用来存储新的元素，不就行了吗？

**不行的，连续内存必须一次性分配，分配完了之后就不能随意增减了**。因为你这块连续内存后面的内存空间可能已经被其他程序占用了，不能说你想要就给你。

那怎么办呢？只能重新申请一块更大的内存空间，把原来的数据复制过去，再插入新的元素，这就是数组的「扩容」操作。

比方说，我重新创建一个更大的数组 `int arr[20]`，然后把原来的 10 个元素复制过去，这样就有空余位置插入新的元素了。

大概的逻辑是这样的：

```java
// 大小为 10 的数组已经装满了
int[] arr = new int[10];
for (int i = 0; i < 10; i++) {
    arr[i] = i;
}

// 现在想在数组末尾追加一个元素 10
// 需要先扩容数组
int[] newArr = new int[20];
// 把原来的 10 个元素复制过去
for (int i = 0; i < 10; i++) {
    newArr[i] = arr[i];
}

// 旧数组的内存空间将由垃圾收集器处理
// ...

// 在新的大数组中追加新元素
newArr[10] = 10;
```

**综上，数组的扩容操作会涉及到新数组的开辟和数据的复制，时间复杂度是 $O(N)$。**



#### 删

删除元素的操作和增加元素的操作类似，也需要分情况讨论。

**情况一，删除末尾元素**

比方说，我有一个大小为 10 的数组，里面装了 5 个元素，现在想删除末尾的元素，怎么办？

很简单，直接把末尾元素标记为一个特殊值代表已删除就行了，我们这里简单举例，就用 -1 作为特殊值代表已删除好了。后面带大家具体实现动态数组的时候，会有更完善的方法删除数组元素，这里只是为了说明删除数组尾部元素的本质就是进行一次随机访问，时间复杂度是 $O(1)$。

大概的代码逻辑是这样的：

```java
// 大小为 10 的数组已经装了 5 个元素
int[] arr = new int[10];
for (int i = 0; i < 5; i++) {
    arr[i] = i;
}

// 删除末尾元素，暂时用 -1 代表元素已删除
arr[4] = -1;
```



**情况二，删除中间元素**

比方说，我有一个大小为 10 的数组，里面装了 5 个元素，现在想删除第 2 个元素（`arr[1]`），怎么办？

这也要涉及「数据搬移」，把被删元素后面的元素都往前移动一位，保持数组元素的连续性。

大概的代码逻辑是这样的：

```java
// 大小为 10 的数组已经装了 5 个元素
int[] arr = new int[10];
for (int i = 0; i < 5; i++) {
    arr[i] = i;
}

// 删除 arr[1]
// 需要把 arr[1] 之后的元素都往前移动一位
// 注意要正着遍历数组中已有元素避免覆盖，不懂的话请看下方可视化面板
for (int i = 1; i < 4; i++) {
    arr[i] = arr[i + 1];
}

// 最后一个元素置为 -1 代表已删除
arr[4] = -1;
```



**综上，在数组中间删除元素的时间复杂度是 $O(N)$，因为涉及到数据搬移**。



### 动态数组

刚才讲了静态数组的超能力和种种局限性，现在讲动态数组，动态数组是静态数组的强化版，也是我们在实际软件开发或者写算法题时最常用的数据结构之一。

首先，你不要以为动态数组可以解决静态数组在中间增删元素效率差的问题，不可能解决的。数组随机访问的超能力源于数组连续的内存空间，而连续的内存空间就不可避免地面对数据搬移和扩缩容的问题。

**动态数组底层还是静态数组，只是自动帮我们进行数组空间的扩缩容，并把增删查改操作进行了封装，让我们使用起来更方便而已**。

简单列举一下各个语言的动态数组使用方法：

```java
// 创建动态数组
// 不用显式指定数组大小，它会根据实际存储的元素数量自动扩缩容
ArrayList<Integer> arr = new ArrayList<>();

for (int i = 0; i < 10; i++) {
    // 在末尾追加元素，时间复杂度 O(1)
    arr.add(i);
}

// 在中间插入元素，时间复杂度 O(N)
// 在索引 2 的位置插入元素 666
arr.add(2, 666);

// 在头部插入元素，时间复杂度 O(N)
arr.add(0, -1);

// 删除末尾元素，时间复杂度 O(1)
arr.remove(arr.size() - 1);

// 删除中间元素，时间复杂度 O(N)
// 删除索引 2 的元素
arr.remove(2);

// 根据索引查询元素，时间复杂度 O(1)
int a = arr.get(0);

// 根据索引修改元素，时间复杂度 O(1)
arr.set(0, 100);

// 根据元素值查找索引，时间复杂度 O(N)
int index = arr.indexOf(666);
```

在后面的章节，我会手把手带大家实现一个动态数组，让大家更加深入地理解动态数组的原理。





### 环形数组技巧及实现

一句话总结:

环形数组技巧利用求模（余数）运算，将普通数组变成逻辑上的环形数组，可以让我们用 $O(1)$ 的时间在数组头部增删元素。

> 这里解释一下
>
> #### 1.取余
>
> 在计算机内存里，数组其实还是直的。我们怎么让它在逻辑上“首尾相连”呢？**靠的就是 `%`（取余）。**
>
> 假设数组长度 `length = 5`：
>
> - **向后走（顺时针）：** `(i + 1) % 5`。 当 `i = 4` 时，`(4 + 1) % 5 = 0`。看！它从末尾跳回了开头！
> - **向前走（逆时针）：** `(i - 1 + 5) % 5`。 当 `i = 0` 时，`(0 - 1 + 5) % 5 = 4`。看！它从开头跳回了末尾！
>
> 为什么要-1?
>
> - 是因为我想去前一个格子,假设你现在站在 **0 号格**（数组的第一个位置）,往前走一格，`0 - 1 = -1`。
>
> 但为什么要+5,而不能直接 `(0 - 1) % 5`？?
>
> - 因为在很多编程语言（包括 Java）中，负数取模的结果可能是负数（比如 `-1 % 5` 结果是 `-1`），这依然没法用作数组索引。
>
> 
>
> #### 2.复杂度为$O(1)$
>
> 假设我们有一个长度为 **5** 的物理数组，现在里面只有 **a, b, c** 三个元素。
>
> 在环形结构里，`head` 和 `tail` 不一定非要从 0 开始。假设初始状态如下：
>
> **物理存储：** `[ _, a, b, c, _ ]` （下划线代表空位）
>
> **索引位置：**     ` 0, 1, 2, 3, 4`
>
> **指针状态：** `head = 1` (指向 a), `tail = 3` (指向 c)
>
> 
>
> **现在执行动作：在头部插入元素 `d` （即 `addFirst(d)`）**
>
> 如果我们按照普通数组的逻辑，要把 `a, b, c` 都往后挪一位，腾出 `index 1` 给 `d`。但环形数组不这么干。
>
> 第一步：计算新 `head` 的位置
>
> 利用我们学过的“向左走”公式：
>
> $$newHead = (head - 1 + 5) \% 5$$
>
> $$newHead = (1 - 1 + 5) \% 5 = 0$$
>
> 
>
> 第二步：填入数据
>
> 把 `d` 放入物理数组的 `index 0`。
>
> - **物理存储：** `[ d, a, b, c, _ ]`
>
> 
>
> 第三步：更新指针
>
> `head` 变为 `0`。此时，逻辑上的顺序是 `head(0) -> 1 -> 2 -> 3(tail)`，即 `d, a, b, c`。
>
> **为什么这次操作是 $O(1)$？**
>
> 你看，计算机只是做了一次减法、一次取模、一次赋值。**a, b, c 动都没动**。
>
> 
>
> 动作：再在头部插入元素 `e` （见证“环形”的瞬间）
>
> 现在我们想再加一个 `e`。
>
> 第一步：计算新 `head`
>
> $$newHead = (head - 1 + 5) \% 5$$
>
> 由于现在的 `head` 是 `0`：
>
> $$newHead = (0 - 1 + 5) \% 5 = 4$$
>
> 第二步：填入数据
>
> 把 `e` 放入物理数组的 `index 4`。
>
> - **物理存储：** `[ d, a, b, c, e ]` （注意！e 跑到数组末尾去了）
>
> 第三步：更新指针
>
> `head` 变为 `4`。
>
> 
>
> 虽然物理上数组看起来乱七八糟 `[d, a, b, c, e]`，但对于 `ArrayDeque` 来说，它只认指针：
>
> - 它从 `head` (索引 4) 开始读：第一个是 **e**。
> - 下一位 `(4+1)%5 = 0`：第二个是 **d**。
> - 下一位 `(0+1)%5 = 1`：第三个是 **a**。
> - 以此类推...
>
> **逻辑顺序变成了：e -> d -> a -> b -> c**
>
> 当然如果是快满了,java会自动检测到 `head` 和 `tail` 快要碰头,然后执行扩容



## 环形数组原理

上面介绍了基本概念,那么我们来看看原理,其实也属于上面的概念扩展

首先数组可能是环形的么？不可能。数组就是一块线性连续的内存空间，怎么可能有环的概念？

但是，我们可以在「逻辑上」把数组变成环形的,所以**环形数组**始终讨论的逻辑上的闭环，比如下面这段代码：

```java
// 长度为 5 的数组
int[] arr = new int[]{1, 2, 3, 4, 5};
int i = 0;
// 模拟环形数组，这个循环永远不会结束
while (i < arr.length) {
    System.out.println(arr[i]);
    i = (i + 1) % arr.length;
}
```

**这段代码的关键在于求模运算 `%`，也就是求余数**。当 `i` 到达数组末尾元素时，`i + 1` 和 `arr.length` 取余数又会变成 0，即会回到数组头部，这样就在逻辑上形成了一个环形数组，永远遍历不完。

这就是环形数组技巧。这个技巧如何帮助我们在 O(1)*O*(1) 的时间在数组头部增删元素呢？

> 下面内容和上面的前言一致,但我写的前言会更加细致一些,看不懂看前言

是这样，假设我们现在有一个长度为 6 的数组，现在其中只装了 3 个元素，如下（未装元素的位置用 `_` 标识）：

```
[1, 2, 3, _, _, _]
```

现在我们要在数组头部删除元素 `1`，那么我们可以把数组变成这样：

```
[_, 2, 3, _, _, _]
```

即，我们仅仅把元素 `1` 的位置标记为空，但并不做数据搬移。

此时，如果我们要在数组头部增加元素 `4` 和元素 `5`，我们可以把数组变成这样：

```
[4, 2, 3, _, _, 5]
```

你可以看到，当头部没有位置添加新元素时，它转了一圈，把新元素加到尾部了。



核心原理

上面只是让大家对环形数组有一个直观地印象，环形数组的关键在于，它维护了两个指针 `start` 和 `end`，`start` 指向第一个有效元素的索引，`end` 指向最后一个有效元素的下一个位置索引。

这样，当我们在数组头部添加或删除元素时，只需要移动 `start` 索引，而在数组尾部添加或删除元素时，只需要移动 `end` 索引。

当 `start, end` 移动超出数组边界（`< 0` 或 `>= arr.length`）时，我们可以通过求模运算 `%` 让它们转一圈到数组头部或尾部继续工作，这样就实现了环形数组的效果。









## 链表（链式存储）基本原理

### 1.定义

如果说**数组**是一排**排好号的电影院座位**（位置固定且连在一起），那么**链表**就是一场**全城范围的寻宝游戏**。

链表（linked list）是一种线性数据结构，其中的每个元素都是一个节点对象，各个节点通过“引用”相连接。引用记录了下一个节点的内存地址，通过它可以从当前节点访问到下一个节点。



链表的“人话”定义:

在链表里，数据不是排排坐的。每个数据（我们叫它**节点 Node**）都住在内存的一个随机角落里。

为了能找到彼此，每个节点手里都拽着一张小纸条，上面写着：**“下一个人的地址在哪里”**。

一个典型的节点包含两部分：

1. **数据域 (Data)：** 存你的宝贝（数字、字符串等）。
2. **指针域 (Next)：** 指向下一个节点的内存地址。

![2.linkedlist_definition](assets/algorithmAssets/2.linkedlist_definition.png)

观察上图:链表的组成单位是节点（node）对象。每个节点都包含两项数据：节点的“值”和指向下一节点的“引用”。

- 链表的首个节点被称为“头节点”，最后一个节点被称为“尾节点”。
- 尾节点指向的是“空”，它在 Java、C++ 和 Python 中分别被记为 `null`、`nullptr` 和 `None` 。
- 在 C、C++、Go 和 Rust 等支持指针的语言中，上述“引用”应被替换为“指针”。





### **2.链表家族**

1. **单链表：** 只有 `Next` 指针。就像单行道，只能往前走，回不了头。
2. **双链表：** 每个节点既有 `Next` 也有 `Prev`（指向前一个）。就像双向车道，虽然费点内存，但更灵活。
3. **循环链表：** 最后一个人的 `Next` 指向了第一个人。像个圆环（常用于解决“约瑟夫环”问题或轮询调度）。



刷过力扣的读者肯定对单链表非常熟悉，力扣上的单链表节点定义如下：

```java
class ListNode {
    int val;
    ListNode next;
    ListNode(int x) { val = x; }
}
```

这仅仅是一个最简单的**单链表节点**，方便力扣出算法题来考你。在实际的编程语言中，我们使用的链表节点会稍微复杂一点，类似这样：

```java
class Node<E> {
    E val;
    Node<E> next;
    Node<E> prev;

    Node(Node<E> prev, E element, Node<E> next) {
        this.val = element;
        this.next = next;
        this.prev = prev;
    }
}
```

主要区别有两个：

1、编程语言标准库一般都会提供泛型，即你可以指定 `val` 字段为任意类型，而力扣的单链表节点的 `val` 字段只有 int 类型。

2、编程语言标准库一般使用的都是双链表而非单链表。单链表节点只有一个 `next` 指针，指向下一个节点；而双链表节点有两个指针，`prev` 指向前一个节点，`next` 指向下一个节点。

有了 `prev` 前驱指针，链表支持双向遍历，但由于要多维护一个指针，增删查改时会稍微复杂一些，后面带大家实现双链表时会具体介绍。



### 3.为什么要发明链表？

数组不是挺好吗？

前面介绍了 [数组（顺序存储）的底层原理](https://labuladong.online/zh/algo/data-structure-basic/array-basic/)，说白了就是一块连续的内存空间，有了这块内存空间的首地址，就能直接通过索引计算出任意位置的元素地址。

链表不一样，一条链表并不需要一整块连续的内存空间存储元素。链表的元素可以分散在内存空间的天涯海角，通过每个节点上的 `next, prev` 指针，将零散的内存块串联起来形成一个链式结构。

这样做的好处很明显，首先就是可以提高内存的利用效率，链表的节点不需要挨在一起，给点内存 new 出来一个节点就能用，操作系统会觉得这娃好养活。

另外一个好处，它的节点要用的时候就能接上，不用的时候拆掉就行了，从来不需要考虑扩缩容和数据搬移的问题，理论上讲，链表是没有容量限制的（除非把所有内存都占满，这不太可能）。

当然，不可能只有好处没有局限性。数组最大的优势是支持通过索引快速访问元素，而链表就不支持。

这个不难理解吧，因为元素并不是紧挨着的，所以如果你想要访问第 3 个链表元素，你就只能从头结点开始往顺着 `next` 指针往后找，直到找到第 3 个节点才行。

上面是对链表这种数据结构的基本介绍，接下来我们就结合代码实现单/双链表的几个基本操作。



> 附上数组和链表的对比

| **特性**            | **数组 (Array)**              | **链表 (Linked List)**      | **谁赢了？** |
| ------------------- | ----------------------------- | --------------------------- | ------------ |
| **找第 i 个元素**   | 瞬间找到 ($O(1)$)             | 得从头一个一个数 ($O(n)$)   | **数组**     |
| **在中间插入/删除** | 后面所有人都要挪位置 ($O(n)$) | 只要把“纸条”改一下 ($O(1)$) | **链表**     |
| **内存分配**        | 必须提前要一块连续的大地盘    | 随用随申请，哪里有空住哪里  | **链表**     |



### 4.ListNode和DoublyListNode到底是什么:

在之后我们很快就会见到ListNode和DoublyListNode,来说一下他们这个类到底是什么:

<span style="color:red">DoublyNodeList里面存储着val以及prev和next的DoublyNodeList对象,然后这里的prev和next是以地址存在的,在实际我们的遍历中,是通过next以及prev的地址然后得到对应的prev以及next的DoublyNodeList对象,然后里面存储着下下一个(相对于首个节点而言)的val以及prev和next的DoublyNodeList对象,这样在遍历的**感官**上让我们感觉好像拥有了prev以及next里的内容,但**实际上只根据当前节点根本不知道下一个节点里的实际内容,因为本质上是地址**,然后我们是通过地址访问相当于才跳转并刷新出下一个节点的内容,再不进入下一个节点之前,当前节点的next实际上存储的只是冷冰冰的地址</span>



### 单链表

#### 基本操作

我先写一个工具函数，用于创建一条单链表，方便后面的讲解：

```java
class ListNode {
    int val;
    ListNode next;
    ListNode(int x) { val = x; }
}

// 输入一个数组，转换为一条单链表
ListNode createLinkedList(int[] arr) {
    if (arr == null || arr.length == 0) {
        return null;
    }
    //不变的头
    ListNode head = new ListNode(arr[0]);
    //cur是一个随时往下走的指针
    ListNode cur = head;
    for (int i = 1; i < arr.length; i++) {
        cur.next = new ListNode(arr[i]);
        cur = cur.next;
    }
    return head;
}
```





对于上面整个自定义的工具类多说一下,我们不依赖createLinkedList手动就可以实现链表,createLinkedList把手动指定的环节 工具化:

```java
ListNode a = new ListNode(1);
ListNode b = new ListNode(2);
ListNode c = new ListNode(3);

a.next = b;
b.next = c;


ListNode pointer = a;
while(pointer!=null){
	System.out.println(pointer.val);
    pointer = pointer.next;
}

```

重点就在 ListNode里的next,彼此通过next连接,此时的初始值pointer存储的是数值"1"以及1下一个地址("2"的地址)

我们一步一步来看;
①ListNode a = new ListNode(1);

此时a只有数值val=1,还没有next的值,此时为null

②然后a.next = b;

此时a就有了数值val=1 以及下一个的地址(也就是数值为2名为b的**地址**)

b和c以及未来新加的都同理,所以当连起来后,只要知道a,尽管a只有b的值,从他开始他也会知道b,c乃至未来的d,e

然后pointer(header)在这里就是从第一个开始,然后一个遍历而已

知道这个就明白:`createLinkedList`是帮我们把手动a.next = b的这个过程通过遍历来实现了





#### 查/改

**单链表的遍历/查找/修改**

比方说，我想访问单链表的每一个节点，并打印其值，可以这样写：

```java
// 创建一条单链表
ListNode head = createLinkedList(new int[]{1, 2, 3, 4, 5});

// 遍历单链表
for (ListNode p = head; p != null; p = p.next) {
    System.out.println(p.val);
}
```

类似的，如果是要通过索引访问或修改链表中的某个节点，也只能用 for 循环从头结点开始往后找，直到找到索引对应的节点，然后进行访问或修改。

这个操作的最坏时间复杂度是 O(n)*O*(*n*)，其中 n*n* 是链表的长度。



#### 增

##### 1.在单链表头部插入新元素

我们会持有单链表的头结点，所以只需要将插入的节点接到头结点之前，并将新插入的节点作为头结点即可。

```java
// 创建一条单链表
ListNode head = createLinkedList(new int[]{1, 2, 3, 4, 5});

// 在单链表头部插入一个新节点 0
ListNode newNode = new ListNode(0);
//此时已经连上了
newNode.next = head;
//这一步的意义是让火车头知道谁是新的,不然每次要通过mewNode从头开始不利于规范
head = newNode;

// 现在链表变成了 0 -> 1 -> 2 -> 3 -> 4 -> 5
```

这个操作的时间复杂度是 $O(1)$。



##### 2.在单链表尾部插入新元素

直接看代码吧，很简单：

```java
// 创建一条单链表
ListNode head = createLinkedList(new int[]{1, 2, 3, 4, 5});

// 在单链表尾部插入一个新节点 6
ListNode p = head;
// 先走到链表的最后一个节点
while (p.next != null) {
    p = p.next;
}
// 现在 p 就是链表的最后一个节点
// 在 p 后面插入新节点
p.next = new ListNode(6);

// 现在链表变成了 1 -> 2 -> 3 -> 4 -> 5 -> 6
```

这个操作的时间复杂度是 O(n)，因为需要先遍历到链表尾部。当然，如果我们持有对链表尾节点的引用，那么在尾部插入新节点的操作就会变得非常简单，不用每次从头去遍历了。这个优化会在后面具体实现双链表时介绍。



##### 3.在单链表中间插入新元素

这个操作稍微有点复杂，我们还是要先找到要插入位置的前驱节点，然后操作前驱节点把新节点插入进去：

```java
// 创建一条单链表
ListNode head = createLinkedList(new int[]{1, 2, 3, 4, 5});

// 在第 3 个节点后面插入一个新节点 66
// 先要找到前驱节点，即第 3 个节点
ListNode p = head;
for (int i = 0; i < 2; i++) {
    p = p.next;
}
// 此时 p 指向第 3 个节点
// 组装新节点的后驱指针
ListNode newNode = new ListNode(66);
newNode.next = p.next;

// 插入新节点
p.next = newNode;

// 现在链表变成了 1 -> 2 -> 3 -> 66 -> 4 -> 5
```

这个操作的时间复杂度是 $O(n)$，因为需要先找到插入位置的前驱节点。



#### 删

##### 1.在单链表中删除一个节点

删除一个节点，首先要找到要被删除节点的前驱节点，然后把这个前驱节点的 `next` 指针指向被删除节点的下一个节点。这样就能把被删除节点从链表中摘除了。

```java
// 创建一条单链表
ListNode head = createLinkedList(new int[]{1, 2, 3, 4, 5});

// 删除第 4 个节点，要操作前驱节点
ListNode p = head;
for (int i = 0; i < 2; i++) {
    p = p.next;
}

// 此时 p 指向第 3 个节点，即要删除节点的前驱节点
// 把第 4 个节点从链表中摘除
p.next = p.next.next;

// 现在链表变成了 1 -> 2 -> 3 -> 5
```

这个操作的时间复杂度是 $O(n)$，因为需要先找到被删除节点的前驱节点。



##### 2.在单链表尾部删除元素

这个操作比较简单，找到倒数第二个节点，然后把它的 `next` 指针置为 null 就行了：

```java
// 创建一条单链表
ListNode head = createLinkedList(new int[]{1, 2, 3, 4, 5});

// 删除尾节点
ListNode p = head;
// 找到倒数第二个节点
while (p.next.next != null) {
    p = p.next;
}

// 此时 p 指向倒数第二个节点
// 把尾节点从链表中摘除
p.next = null;

// 现在链表变成了 1 -> 2 -> 3 -> 4
```

这个操作的时间复杂度是 $O(n)$，因为需要先遍历到倒数第二个节点。



##### 3.在单链表头部删除元素

这个操作比较简单，直接把 `head` 移动到下一个节点就行了，直接看代码吧：

```java
// 创建一条单链表
ListNode head = createLinkedList(new int[]{1, 2, 3, 4, 5});

// 删除头结点
head = head.next;

// 现在链表变成了 2 -> 3 -> 4 -> 5
```

这个操作的时间复杂度是 $O(1)$。

不过可能有读者疑惑，之前那个旧的头结点 `1` 的 next 指针依然指向着节点 `2`，这样会不会造成内存泄漏？

不会的，这个节点 `1` 指向其他的节点是没关系的，只要保证没有其他引用指向这个节点 `1`，它就能被垃圾回收器回收掉。

当然，如果你非要显式把节点 `1` 的 next 指针置为 null，这是个很好的习惯，在其他场景中可能可以避免指针错乱的潜在问题。

在下面这个可视化面板中，我显式地把待删除节点的 next 指针置为 null 了：

> 链表的增删查改操作确实比数组复杂。这是因为链表的节点不是紧挨着的，所以要增删一个节点，必须先找到它的前驱和后驱节点进行协同，然后才能通过指针操作把它插入或删除。
>
> 上面给出的代码还仅仅是最简单的例子，你会发现在头部、尾部、中间增删元素的代码都不一样。如果要实现一个真正可用的链表，你还要考虑到很多边界情况，比如链表可能为空、前后驱节点可能为空等，这些情况都得保证不出错。
>
> 而且，上面只是介绍了「单链表」，而我们下一章要实现的是「双链表」，双链表要同时维护前驱和后驱指针，指针操作会更复杂一些。
>
> 是不是已经不敢想了？不要怕，其实没你想的那么难，几个原因：
>
> 1、其实搞来搞去就那几个操作，等会儿带你动手实现链表 API 的时候，你亲自写一写，就会了。
>
> 2、复杂操作我都配了可视化面板，你可以结合面板中的代码和动画进行理解。
>
> 3、最重要的，我们会使用「**虚拟头结点**」技巧，把头、尾、中部的操作统一起来，同时还能避免处理头尾指针为空情况的边界情况。
>
> 虚拟节点技巧在 [单链表经典算法技巧](https://labuladong.online/zh/algo/essential-technique/linked-list-skills-summary/) 中也会经常运用，这里仅仅简单提一下，具体实现会在后面讲到。



### 双链表

#### 基本操作

先写一个工具函数，用于创建一条双链表，方便后面的讲解：

```java
class DoublyListNode {
    int val;
    DoublyListNode next, prev;
    DoublyListNode(int x) { val = x; }
}

DoublyListNode createDoublyLinkedList(int[] arr) {
    if (arr == null || arr.length == 0) {
        return null;
    }
    DoublyListNode head = new DoublyListNode(arr[0]);
    DoublyListNode cur = head;
    // for 循环迭代创建双链表
    for (int i = 1; i < arr.length; i++) {
        DoublyListNode newNode = new DoublyListNode(arr[i]);
        cur.next = newNode;
        newNode.prev = cur;
        cur = cur.next;
    }
    return head;
}
```



#### 查/改

> 双链表的遍历/查找/修改

对于双链表的遍历和查找，我们可以从头节点或尾节点开始，根据需要向前或向后遍历：

```java
// 创建一条双链表
DoublyListNode head = createDoublyLinkedList(new int[]{1, 2, 3, 4, 5});
DoublyListNode tail = null;

// 从头节点向后遍历双链表
for (DoublyListNode p = head; p != null; p = p.next) {
    System.out.println(p.val);
    tail = p;
}

// 从尾节点向前遍历双链表
for (DoublyListNode p = tail; p != null; p = p.prev) {
    System.out.println(p.val);
}
```

这个操作的最坏时间复杂度是 $O(n)$。访问或修改节点时，可以根据索引是靠近头部还是尾部，选择合适的方向遍历，这样可以一定程度上提高效率。



#### 增

##### 1.在双链表头部插入新元素

在双链表头部插入元素，需要调整新节点和原头节点的指针：

```java
// 创建一条双链表
DoublyListNode head = createDoublyLinkedList(new int[]{1, 2, 3, 4, 5});

// 在双链表头部插入新节点 0
DoublyListNode newHead = new DoublyListNode(0);
newHead.next = head;
head.prev = newHead;
head = newHead;
// 现在链表变成了 0 -> 1 -> 2 -> 3 -> 4 -> 5
```

这个操作的时间复杂度是 $O(1)$。



##### 2.在双链表尾部插入新元素

在双链表尾部插入元素时，如果我们持有尾节点的引用，这个操作会非常简单：

```java
// 创建一条双链表
DoublyListNode head = createDoublyLinkedList(new int[]{1, 2, 3, 4, 5});

DoublyListNode tail = head;
// 先走到链表的最后一个节点
while (tail.next != null) {
    tail = tail.next;
}

// 在双链表尾部插入新节点 6
DoublyListNode newNode = new DoublyListNode(6);
tail.next = newNode;
newNode.prev = tail;
// 更新尾节点引用
tail = newNode;

// 现在链表变成了 1 -> 2 -> 3 -> 4 -> 5 -> 6
```

这个操作的时间复杂度是 $O(n)$，因为需要先遍历到尾节点。如果持有尾节点引用，则是 $O(1)$。



##### 3.在双链表中间插入新元素

在双链表的指定位置插入新元素，需要调整前驱节点和后继节点的指针。

比如下面的例子，把元素 66 插入到索引 3（第 4 个节点）的位置：

```java
// 创建一条双链表
DoublyListNode head = createDoublyLinkedList(new int[]{1, 2, 3, 4, 5});

// 想要插入到索引 3（第 4 个节点）
// 需要操作索引 2（第 3 个节点）的指针
DoublyListNode p = head;
for (int i = 0; i < 2; i++) {
    p = p.next;
}

// 组装新节点
DoublyListNode newNode = new DoublyListNode(66);
newNode.next = p.next;
newNode.prev = p;

// 插入新节点
p.next.prev = newNode;
p.next = newNode;

// 现在链表变成了 1 -> 2 -> 3 -> 66 -> 4 -> 5
```

这个操作的时间复杂度是 $O(n)$，因为需要先找到插入位置。



#### 删

##### 1.在双链表中删除一个节点

在双链表中删除节点时，需要调整前驱节点和后继节点的指针来摘除目标节点：

```
// 创建一条双链表
DoublyListNode head = createDoublyLinkedList(new int[]{1, 2, 3, 4, 5});

// 删除第 4 个节点
// 先找到第 3 个节点
DoublyListNode p = head;
for (int i = 0; i < 2; i++) {
    p = p.next;
}

// 现在 p 指向第 3 个节点，我们它后面那个节点摘除出去
DoublyListNode toDelete = p.next;

// 把 toDelete 从链表中摘除
p.next = toDelete.next;
toDelete.next.prev = p;

// 把 toDelete 的前后指针都置为 null 是个好习惯（可选）
toDelete.next = null;
toDelete.prev = null;

// 现在链表变成了 1 -> 2 -> 3 -> 5
```

当然为了安全性向大厂看齐建议写成:

```java
DoublyListNode head = DoublyListNode.createDoublyLinkedList(new int[]{1,2,3,00,5,6,7});
DoublyListNode p = head;
for (int i = 0; i < 2; i++) {
     p = p.next;
}
DoublyListNode toDelete = p.next;
DoublyListNode boundTest = toDelete.next;

p.next = boundTest;
if (boundTest != null){
     toDelete.next.prev = p;
}


toDelete.next = null;
toDelete.prev = null;
toDelete.printList();
head.printList();
```

>  其中之所以`p.next = boundTest;`在if外面是因为有可能我们删除的是最后一个元素,而boundTest此时就是最后一个元素的next,所以当然有可能为null
>
> 然后是为什么要判断`boundTest != null`因为如果boundTest是null,那么就会触发`NullPointerException (NPE，空指针异常)。`而众所周知,`null` 在内存中代表“什么都没有”。,不能让“什么都没有”去执行动作。
>
> 然后手动写null会防止内存泄漏,是个好习惯



##### 2.在双链表头部删除元素

在双链表头部删除元素需要调整头节点的指针

```java
// 创建一条双链表
DoublyListNode head = createDoublyLinkedList(new int[]{1, 2, 3, 4, 5});

// 删除头结点
DoublyListNode toDelete = head;
head = head.next;
head.prev = null;

// 清理已删除节点的指针
toDelete.next = null;

// 现在链表变成了 2 -> 3 -> 4 -> 5
```

然后工业级开发:

```java
public int pollFirst() {
    // 1. 暂存当前头节点 (f 代表 first)
    final DoublyListNode f = head;
    if (f == null) return -1; // 判空

    int element = f.val;
    // 2. 暂存下一个节点
    final DoublyListNode nextNode = f.next;

    // 3. 斩断旧头的后路 (帮助 GC)
    f.next = null; 

    // 4. 移动 head 指针
    head = nextNode;

    // 5. 处理新头的路标
    if (nextNode == null) {
        // 说明删掉的是最后一个节点，tail 也要置空
        tail = null; 
    } else {
        // 斩断新头的前路，彻底孤立旧头
        nextNode.prev = null;
    }

    size--;
    return element;
}
```

以上的所有目的都是为了防止内存泄漏

这个操作的时间复杂度是 $O(1)$。



##### 3.在双链表尾部删除元素

在单链表中，由于缺乏前驱指针，所以删除尾节点时需要遍历到倒数第二个节点，操作它的 `next` 指针，才能把尾节点摘除出去。

但在双链表中，由于每个节点都存储了前驱节点的指针，所以我们可以直接操作尾节点，把它自己从链表中摘除

```
// 创建一条双链表
DoublyListNode head = createDoublyLinkedList(new int[]{1, 2, 3, 4, 5});

// 删除尾节点
DoublyListNode p = head;
// 找到尾结点
while (p.next != null) {
    p = p.next;
}

// 现在 p 指向尾节点
// 把尾节点从链表中摘除
p.prev.next = null;

// 把被删结点的指针都断开是个好习惯（可选）
p.prev = null;

// 现在链表变成了 1 -> 2 -> 3 -> 4
```

这个操作的时间复杂度是 $O(n)$，因为需要先遍历到尾节点。如果持有尾节点引用，则是 $O(1)。$



## 队列/栈基本原理

计算机的两种存储方式，顺序存储（数组）和链式存储（链表）都讲完了，之后的所有数据结构都是基于这两种存储方式之上玩花活。

本文讲解队列和栈的基本原理，后面的文章会讲解如何用代码具体实现。

先说概念吧，其实队列和栈都是**「操作受限」**的数据结构。说它操作受限，主要是和基本的数组和链表相比，它们提供的 API 是不完整的。

比方说我们前面实现的数组和链表，增删查改的 API 都实现过了，你可以对任意一个索引元素进行增删查改，只要索引不越界，就随便你。

> 数组和链表是**物理存储结构**。它们非常大方，给你提供了最高的自由度：
>
> - 你想看第 5 个元素？没问题（下标或遍历）。
> - 你想在第 3 个位置插个数据？随你便。
> - 你想改掉中间那个数？请便。
>
> > **总结：** 它们像是一张白纸，你想在哪个位置写字、擦字都可以。

但是对于队列和栈，它们的操作是受限的：**队列只能在一端插入元素，另一端删除元素；栈只能在某一端插入和删除元素**。说白了就是把数组链表提供的 API 删掉了一部分，只保留头尾操作元素的 API 给你用。

> 栈和队列**逻辑结构**。它们在底层其实就是用数组或链表实现的，但它们故意把那些自由的功能“阉割”掉了，只留下最核心的两个操作：
>
> - **栈 (Stack)：** 只准你在**一端**进出。像一桶薯片，你不能直接拿最底下的，必须先吃掉上面的。这就是 **LIFO (后进先出)**。
> - **队列 (Queue)：** 只准你在**队尾**进，**队头**出。像排队买奶茶，不准插队，不准从中间离场。这就是 **FIFO (先进先出)**。

形象地理解，队列只允许在队尾插入元素，在队头删除元素，栈只允许在栈顶插入元素，从栈顶删除元素。这个图中把栈竖着画，队列横着画，只是为了更形象，但实际上它们底层都是数组和链表实现的，后面会讲到：

![4.queueAndStack](assets/algorithmAssets/4.queueAndStack.png)

队列就像排队买票，先来的先离开，后来的后离开；栈就像一摞盘子，最先放的压在最下面，最后放的留在最上面，拿的时候也是最上面的先被拿走。所以我们常说，队列是一种「先进先出」的数据结构，栈是一种「先进后出」的数据结构，就是这个道理。



> 为什么非要“受限”？（核心原因）
>
> 你可能会问：“明明数组什么都能干，为什么我还要用一个‘残缺’的栈或队列？”
>
> ### 原因 A：安全性（防止乱搞）
>
> 在很多场景下，我们**不希望**数据被随意修改。
>
> - **场景：** 浏览器的“后退”功能。
> - 如果用数组实现，不小心删掉了中间的一个历史记录，那“后退”逻辑就全乱了。
> - 如果封装成一个**栈**，程序员就只能操作“最近的一个页面”，从机制上保证了业务逻辑的正确性。
>
> ### 原因 B：语义化（代码更好懂）
>
> 当你声明一个 `Stack` 时，别的程序员一看就懂：“哦，这里的数据处理遵循先进后出。” 如果你用一个 `Array` 来模拟，别人还得研究你到底是 `push` 还是 `unshift`，增加了维护成本。



这两种数据结构的基本 API 如下：

```java
// 队列的基本 API
class MyQueue<E> {
    // 向队尾插入元素，时间复杂度 O(1)
    void push(E e);

    // 从队头删除元素，时间复杂度 O(1)
    E pop();

    // 查看队头元素，时间复杂度 O(1)
    E peek();

    // 返回队列中的元素个数，时间复杂度 O(1)
    int size();
}

// 栈的基本 API
class MyStack<E> {
    // 向栈顶插入元素，时间复杂度 O(1)
    void push(E e);

    // 从栈顶删除元素，时间复杂度 O(1)
    E pop();

    // 查看栈顶元素，时间复杂度 O(1)
    E peek();

    // 返回栈中的元素个数，时间复杂度 O(1)
    int size();
}
```

不同编程语言中，队列和栈提供的方法名称可能不一样，但每个方法的效果肯定是一样的。

有些语言的标准库可能没有直接提供队列和栈，你可以自己用数组或者链表模拟出队列和栈的效果。下一章我就会先带你用链表实现队列和栈。
