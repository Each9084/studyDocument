# 基础

## 简单理解

1、时空复杂度用 Big O 表示法表示（类似 O(1),O(n2),O(logn)*O*(1),*O*(*n*2),*O*(*l**o**g**n*) 等）。**它们都是估计值，不需要精确计算，常数项和低增长项都可以忽略，仅需保留最高增长项**。

比方说 O(2n2+3n+1)*O*(2*n*2+3*n*+1) 等同于 O(n2)*O*(*n*2)，O(1000n+1000)*O*(1000*n*+1000) 等同于 O(n)*O*(*n*)。

2、我们分析算法复杂度时，分析的是最坏情况的复杂度。这一点会在下面的示例中体现。

3、时间复杂度用来衡量一个算法的执行效率，空间复杂度用来衡量算法的内存消耗，它们都是越小越好。

比方说时间复杂度 O(n)*O*(*n*) 的算法比 O(n2)*O*(*n*2) 的算法执行效率高，空间复杂度 O(1)*O*(1) 的算法比 O(n)*O*(*n*) 的算法内存消耗小。

当然，一般我们要说明这个 n*n* 代表什么，比如 n*n* 代表输入的数组的长度。

4、如何估算？**现在你可以简单理解：时间复杂度大部分情况下就是看 for 循环的最大嵌套层数；空间复杂度就看算法申请了多少空间来存储数据**



## 时间/空间复杂度案例分析

**示例一，时间复杂度 $O(n)$，空间复杂度 $O(1)\$**：

```java
// 输入一个整数数组，返回所有元素的和
int getSum(int[] nums) {
    int sum = 0;
    for (int i = 0; i < nums.length; i++) {
        sum += nums[i];
    }
    return sum;
}
```

算法包含一个 for 循环遍历 `nums` 数组，所以时间复杂度是$ O(n)$，其中 `n` 代表 `nums` 数组的长度。

我们的算法只使用了一个 `sum` 变量，这个 `nums` 是题目给的输入，不算在我们算法的空间复杂度里面，所以空间复杂度是 $ O(1)$。



**示例二，时间复杂度 $O(n)$，空间复杂度 $O(1)$**：

```java
// 当 n 是 10 的倍数时，计算累加和，否则返回 -1
int sum(int n) {
    if (n % 10 != 0) {
        return -1;
    }
    int sum = 0;
    for (int i = 0; i <= n; i++) {
        sum += i;
    }
    return sum;
}
```

其实只有当 `n` 是 10 的倍数时，算法才会执行 for 循环，时间复杂度是 $O(n)$。其他情况下算法会直接返回，时间复杂度是 $O(1)$。

但是算法复杂度只考察最坏情况，所以这个算法的时间复杂度是 $O(n)$，空间复杂度是 $O(1)$。



**示例三，时间复杂度 $O(n^2)$，空间复杂度 $O(1)$**：

```java
// 数组是否存在两个数，它们的和为 target？
boolean hasTargetSum(int[] nums, int target) {
    for (int i = 0; i < nums.length; i++) {
        for (int j = i + 1; j < nums.length; j++) {
            if (nums[i] + nums[j] == target) {
                return true;
            }
        }
    }
    return false;
}
```

算法嵌套了两层 for 循环，所以时间复杂度是 $O(n^2)$，其中 $n$ 代表 `nums` 数组的长度。

我们的算法只使用了 `i, j` 两个变量，这是常数级别的空间消耗，所以空间复杂度是 O(1)*O*(1)。

你也许会说，内层的 for 循环并没有遍历整个数组，且有可能提前 return，算法实际执行的次数应该是小于$ n^2$ 的，时间复杂度还是 $O(n^2)$吗？

是的，还是 $O(n^2)$。具体到不同的输入，算法的实际执行次数确实会小于 $O(n^2)$，但我们不需要关心这些细节，估算一个最坏情况的时间复杂度就可以了。

每层 for 循环在最坏情况下都是 $O(n)$ 的时间复杂度，套在一起，总的时间复杂度是 $O(n^2)$。



**示例四，时间复杂度 $O(n)$，空间复杂度 $O(n)$**：

```java
void exampleFn(int n) {
    int[] nums = new int[n];
}
```

这个函数中创建了一个大小为 `n` 的数组，所以空间复杂度是 $O(n)$。	

上述代码申请数组空间并将 `n` 个元素初始化为 0。内存申请操作的时间复杂度可以认为是  $O(n)$，但为所有元素赋值的操作相当于一个隐藏的 for 循环（由编程语言为我们自动完成），时间复杂度是  $O(n)$。所以总的时间复杂度是  $O(n)$。

时间复杂度并不仅仅体现在你看得到的 for 循环，每一行代码都可能有隐藏的时间复杂度。所以说要了解编程语言提供的常用数据结构实现原理，这是准确分析时间复杂度的基础。



**示例五，时间复杂度 $O(n)$，空间复杂度 $O(n)$**：

```Java
// 输入一个整数数组，返回一个新的数组，新数组的每个元素是原数组对应元素的平方
int[] squareArray(int[] nums) {
    int[] res = new int[nums.length];
    for (int i = 0; i < nums.length; i++) {
        res[i] = nums[i] * nums[i];
    }
    return res;
}
```

算法初始化 `res` 数组需要 $O(n)$ 的时间复杂度，包含一个 for 循环，时间复杂度也是 $O(n)$，总的时间复杂度是还是 $O(n)$ 其中 `n` 代表 `nums` 数组的长度。

我们声明了一个新的数组 `res`，这个数组的长度和 `nums` 数组一样，所以空间复杂度是 O(n)*O*(*n*)。

好了，初学者明白上面这些基本的时间、空间复杂度分析暂时就够用了，继续往下学习吧。



## 数组/动态数组

静态数组在创建的时候就要确定数组的元素类型和元素数量。只有在 C++、Java、Golang 这类语言中才提供了创建静态数组的方式，类似 Python、JavaScript 这类语言并没有提供静态数组的定义方式。

静态数组的用法比较原始，实际软件开发中很少用到，写算法题也没必要用，我们一般直接用动态数组。但为了理解原理，在这里还是要讲解一下。

定义一个静态数组的方法如下：

```java
// 定义一个大小为 10 的静态数组
int[] arr = new int[10];

// 使用索引赋值
arr[0] = 1;
arr[1] = 2;

// 使用索引取值
int a = arr[0];
```



就这，没有其他什么操作了。

拿 C++ 来举例吧，`int arr[10]` 这段代码到底做了什么事情呢？主要有这么几件事：

1、在内存中开辟了一段**连续的内存空间**，大小是 `10 * sizeof(int)` 字节。一个 int 在计算机内存中占 4 字节，也就是总共 40 字节。

2、定义了一个名为 `arr` 的数组指针，指向这段内存空间的首地址。

那么 `arr[1] = 2` 这段代码又做了什么事情呢？主要有这么几件事：

1、计算 `arr` 的首地址加上 `1 * sizeof(int)` 字节（4 字节）的偏移量，找到了内存空间中的第二个元素的**首地址**。

2、从这个地址开始的 4 个字节的内存空间中写入了整数 `2`。

> 写给初学者
>
> 我记得以前刚上大学的时候要学 C 语言基础，有些同学就绕不清楚什么指针的数组，数组的指针，绕来绕去的。其实只要明白了上面这个简单的流程，一切就很清楚了。
>
> 1、为什么数组的索引从 0 开始？就是方便取地址。`arr[0]` 就是 `arr` 的首地址，从这个地址往后的 4 个字节存储着第一个元素的值；`arr[1]` 就是 `arr` 的首地址加上 `1 * 4` 字节，也就是第二个元素的首地址，这个地址往后的 4 个字节存储着第二个元素的值。`arr[2], arr[3]` 以此类推。
>
> 2、因为数组的名字 `arr` 就指向整块内存的首地址，所以数组名 `arr` 就是一个指针。你直接取这个地址的值，就是第一个元素的值。也就是说，`*arr` 的值就是 `arr[0]`，即第一个元素的值。
>
> 3、如果不用 `memset` 这种函数初始化数组的值，那么数组内的值是不确定的。因为 `int arr[10]` 这个语句只是请操作系统在内存中开辟了一块连续的内存空间，你也不知道这块空间是谁使用过的二手内存，你也不知道里面存了什么奇奇怪怪的东西。所以一般我们会用 `memset` 函数把这块内存空间的值初始化一下再使用。
>
> 当然，上面讲的这些内容都是针对 C/C++，因为大家学习计算机基础的时候都接触过。其他比如 Java Golang 这种语言，静态数组创建出来后会自动帮你把元素值都初始化为 0，所以不需要再显式进行初始化。

我梳理一下上面的因果逻辑，静态数组本质上就是一块**连续的**内存空间，`int arr[10]` 这个语句我们可以得知：

1、我们知道这块内存空间的首地址（数组名 `arr` 就指向这块内存空间的首地址）。

2、我们知道了每个元素的类型（比如 int），也就是知道了每个元素占用的内存空间大小（比如一个 int 占 4 字节，32 bit）。

3、这块内存空间是连续的，其大小为 `10 * sizeof(int)` 即 40 字节。

**所以，我们获得了数组的超能力「随机访问」：只要给定任何一个数组索引，我可以在 $O(1)$ 的时间内直接获取到对应元素的值**。

因为我可以通过首地址和索引直接计算出目标元素的内存地址。计算机的内存寻址时间可以认为是 $O(1)$，所以数组的随机访问时间复杂度是 $O(1)$。

但是，一个人最大的优势往往也是他的最大劣势。数组连续内存的特性给了他随机访问的超能力，但它也因此吃了不少苦，下面介绍。



### 增删查改

**数据结构的职责就是增删查改**，再无其他。

那么刚刚介绍数组这种数据结构的底层原理，我们其实只介绍了「查」和「改」的部分，也就是通过索引修改和访问对应元素的值。那么「增删」这两个操作又是如何实现的呢？



#### 增

要想给静态数组增加元素，这就有些复杂了，需要分情况讨论。

**情况一，数组末尾追加（append）元素**

比方说，我有一个大小为 10 的数组，里面装了 4 个元素，现在想在末尾追加一个元素，怎么办？

比较简单，直接在对应的索引赋值就行了，这是大概的代码逻辑：

```java
// 大小为 10 的数组已经装了 4 个元素
int[] arr = new int[10];
for (int i = 0; i < 4; i++) {
    arr[i] = i;
}

// 现在想在数组末尾追加一个元素 4
arr[4] = 4;

// 再在数组末尾追加一个元素 5
arr[5] = 5;

// 依此类推
// ...
```

**可以看到，由于只是对索引赋值，所以在数组末尾追加元素的时间复杂度是 O(1)\*O\*(1)**。

情况二，数组中间插入（insert）元素

比方说，我有一个大小为 10 的数组 `arr`，前 4 个位置装了元素，现在想在第 3 个位置（索引 2 `arr[2]`）插入一个新元素，怎么办？

这就要涉及「数据搬移」，给新元素腾出空位，然后再才能插入新元素。大概的代码逻辑是这样的：

```java
// 大小为 10 的数组已经装了 4 个元素
int[] arr = new int[10];
for (int i = 0; i < 4; i++) {
    arr[i] = i;
}

// 在索引 2 置插入元素 666
// 需要把索引 2 以及之后的元素都往后移动一位
// 注意要倒着遍历数组中已有元素避免覆盖，不懂的话请看下方可视化面板
for (int i = 4; i > 2; i--) {
    arr[i] = arr[i - 1];
}

// 现在第 3 个位置空出来了，可以插入新元素
arr[2] = 666;
```

**综上，在数组中间插入元素的时间复杂度是 $O(N)$，因为涉及到数据搬移，给新元素腾地方**



情况三，数组空间已满

静态数组在创建时就要确定大小，比方说现在我创建了一个数组 `int arr[10]`（一块 40 字节的连续内存空间），然后往里面存了 10 个元素，这时候我想再插入一个元素，怎么办？无论是追加在尾部还是插入到中间，都没有位置留给新元素了。

有的读者可能说，这个简单呀，在这 40 字节后面再加上 4 个字节的连续内存空间，用来存储新的元素，不就行了吗？

**不行的，连续内存必须一次性分配，分配完了之后就不能随意增减了**。因为你这块连续内存后面的内存空间可能已经被其他程序占用了，不能说你想要就给你。

那怎么办呢？只能重新申请一块更大的内存空间，把原来的数据复制过去，再插入新的元素，这就是数组的「扩容」操作。

比方说，我重新创建一个更大的数组 `int arr[20]`，然后把原来的 10 个元素复制过去，这样就有空余位置插入新的元素了。

大概的逻辑是这样的：

```java
// 大小为 10 的数组已经装满了
int[] arr = new int[10];
for (int i = 0; i < 10; i++) {
    arr[i] = i;
}

// 现在想在数组末尾追加一个元素 10
// 需要先扩容数组
int[] newArr = new int[20];
// 把原来的 10 个元素复制过去
for (int i = 0; i < 10; i++) {
    newArr[i] = arr[i];
}

// 旧数组的内存空间将由垃圾收集器处理
// ...

// 在新的大数组中追加新元素
newArr[10] = 10;
```

**综上，数组的扩容操作会涉及到新数组的开辟和数据的复制，时间复杂度是 $O(N)$。**



#### 删

删除元素的操作和增加元素的操作类似，也需要分情况讨论。

**情况一，删除末尾元素**

比方说，我有一个大小为 10 的数组，里面装了 5 个元素，现在想删除末尾的元素，怎么办？

很简单，直接把末尾元素标记为一个特殊值代表已删除就行了，我们这里简单举例，就用 -1 作为特殊值代表已删除好了。后面带大家具体实现动态数组的时候，会有更完善的方法删除数组元素，这里只是为了说明删除数组尾部元素的本质就是进行一次随机访问，时间复杂度是 $O(1)$。

大概的代码逻辑是这样的：

```java
// 大小为 10 的数组已经装了 5 个元素
int[] arr = new int[10];
for (int i = 0; i < 5; i++) {
    arr[i] = i;
}

// 删除末尾元素，暂时用 -1 代表元素已删除
arr[4] = -1;
```



**情况二，删除中间元素**

比方说，我有一个大小为 10 的数组，里面装了 5 个元素，现在想删除第 2 个元素（`arr[1]`），怎么办？

这也要涉及「数据搬移」，把被删元素后面的元素都往前移动一位，保持数组元素的连续性。

大概的代码逻辑是这样的：

```java
// 大小为 10 的数组已经装了 5 个元素
int[] arr = new int[10];
for (int i = 0; i < 5; i++) {
    arr[i] = i;
}

// 删除 arr[1]
// 需要把 arr[1] 之后的元素都往前移动一位
// 注意要正着遍历数组中已有元素避免覆盖，不懂的话请看下方可视化面板
for (int i = 1; i < 4; i++) {
    arr[i] = arr[i + 1];
}

// 最后一个元素置为 -1 代表已删除
arr[4] = -1;
```



**综上，在数组中间删除元素的时间复杂度是 $O(N)$，因为涉及到数据搬移**。



### 动态数组

刚才讲了静态数组的超能力和种种局限性，现在讲动态数组，动态数组是静态数组的强化版，也是我们在实际软件开发或者写算法题时最常用的数据结构之一。

首先，你不要以为动态数组可以解决静态数组在中间增删元素效率差的问题，不可能解决的。数组随机访问的超能力源于数组连续的内存空间，而连续的内存空间就不可避免地面对数据搬移和扩缩容的问题。

**动态数组底层还是静态数组，只是自动帮我们进行数组空间的扩缩容，并把增删查改操作进行了封装，让我们使用起来更方便而已**。

简单列举一下各个语言的动态数组使用方法：

```java
// 创建动态数组
// 不用显式指定数组大小，它会根据实际存储的元素数量自动扩缩容
ArrayList<Integer> arr = new ArrayList<>();

for (int i = 0; i < 10; i++) {
    // 在末尾追加元素，时间复杂度 O(1)
    arr.add(i);
}

// 在中间插入元素，时间复杂度 O(N)
// 在索引 2 的位置插入元素 666
arr.add(2, 666);

// 在头部插入元素，时间复杂度 O(N)
arr.add(0, -1);

// 删除末尾元素，时间复杂度 O(1)
arr.remove(arr.size() - 1);

// 删除中间元素，时间复杂度 O(N)
// 删除索引 2 的元素
arr.remove(2);

// 根据索引查询元素，时间复杂度 O(1)
int a = arr.get(0);

// 根据索引修改元素，时间复杂度 O(1)
arr.set(0, 100);

// 根据元素值查找索引，时间复杂度 O(N)
int index = arr.indexOf(666);
```

在后面的章节，我会手把手带大家实现一个动态数组，让大家更加深入地理解动态数组的原理。



## 链表（链式存储）基本原理

### 1.定义

如果说**数组**是一排**排好号的电影院座位**（位置固定且连在一起），那么**链表**就是一场**全城范围的寻宝游戏**。

链表（linked list）是一种线性数据结构，其中的每个元素都是一个节点对象，各个节点通过“引用”相连接。引用记录了下一个节点的内存地址，通过它可以从当前节点访问到下一个节点。



链表的“人话”定义:

在链表里，数据不是排排坐的。每个数据（我们叫它**节点 Node**）都住在内存的一个随机角落里。

为了能找到彼此，每个节点手里都拽着一张小纸条，上面写着：**“下一个人的地址在哪里”**。

一个典型的节点包含两部分：

1. **数据域 (Data)：** 存你的宝贝（数字、字符串等）。
2. **指针域 (Next)：** 指向下一个节点的内存地址。

![2.linkedlist_definition](assets/algorithmAssets/2.linkedlist_definition.png)

观察上图:链表的组成单位是节点（node）对象。每个节点都包含两项数据：节点的“值”和指向下一节点的“引用”。

- 链表的首个节点被称为“头节点”，最后一个节点被称为“尾节点”。
- 尾节点指向的是“空”，它在 Java、C++ 和 Python 中分别被记为 `null`、`nullptr` 和 `None` 。
- 在 C、C++、Go 和 Rust 等支持指针的语言中，上述“引用”应被替换为“指针”。





### **2.链表家族**

1. **单链表：** 只有 `Next` 指针。就像单行道，只能往前走，回不了头。
2. **双链表：** 每个节点既有 `Next` 也有 `Prev`（指向前一个）。就像双向车道，虽然费点内存，但更灵活。
3. **循环链表：** 最后一个人的 `Next` 指向了第一个人。像个圆环（常用于解决“约瑟夫环”问题或轮询调度）。



刷过力扣的读者肯定对单链表非常熟悉，力扣上的单链表节点定义如下：

```java
class ListNode {
    int val;
    ListNode next;
    ListNode(int x) { val = x; }
}
```

这仅仅是一个最简单的**单链表节点**，方便力扣出算法题来考你。在实际的编程语言中，我们使用的链表节点会稍微复杂一点，类似这样：

```java
class Node<E> {
    E val;
    Node<E> next;
    Node<E> prev;

    Node(Node<E> prev, E element, Node<E> next) {
        this.val = element;
        this.next = next;
        this.prev = prev;
    }
}
```

主要区别有两个：

1、编程语言标准库一般都会提供泛型，即你可以指定 `val` 字段为任意类型，而力扣的单链表节点的 `val` 字段只有 int 类型。

2、编程语言标准库一般使用的都是双链表而非单链表。单链表节点只有一个 `next` 指针，指向下一个节点；而双链表节点有两个指针，`prev` 指向前一个节点，`next` 指向下一个节点。

有了 `prev` 前驱指针，链表支持双向遍历，但由于要多维护一个指针，增删查改时会稍微复杂一些，后面带大家实现双链表时会具体介绍。



### 3.为什么要发明链表？

数组不是挺好吗？

前面介绍了 [数组（顺序存储）的底层原理](https://labuladong.online/zh/algo/data-structure-basic/array-basic/)，说白了就是一块连续的内存空间，有了这块内存空间的首地址，就能直接通过索引计算出任意位置的元素地址。

链表不一样，一条链表并不需要一整块连续的内存空间存储元素。链表的元素可以分散在内存空间的天涯海角，通过每个节点上的 `next, prev` 指针，将零散的内存块串联起来形成一个链式结构。

这样做的好处很明显，首先就是可以提高内存的利用效率，链表的节点不需要挨在一起，给点内存 new 出来一个节点就能用，操作系统会觉得这娃好养活。

另外一个好处，它的节点要用的时候就能接上，不用的时候拆掉就行了，从来不需要考虑扩缩容和数据搬移的问题，理论上讲，链表是没有容量限制的（除非把所有内存都占满，这不太可能）。

当然，不可能只有好处没有局限性。数组最大的优势是支持通过索引快速访问元素，而链表就不支持。

这个不难理解吧，因为元素并不是紧挨着的，所以如果你想要访问第 3 个链表元素，你就只能从头结点开始往顺着 `next` 指针往后找，直到找到第 3 个节点才行。

上面是对链表这种数据结构的基本介绍，接下来我们就结合代码实现单/双链表的几个基本操作。



> 附上数组和链表的对比

| **特性**            | **数组 (Array)**              | **链表 (Linked List)**      | **谁赢了？** |
| ------------------- | ----------------------------- | --------------------------- | ------------ |
| **找第 i 个元素**   | 瞬间找到 ($O(1)$)             | 得从头一个一个数 ($O(n)$)   | **数组**     |
| **在中间插入/删除** | 后面所有人都要挪位置 ($O(n)$) | 只要把“纸条”改一下 ($O(1)$) | **链表**     |
| **内存分配**        | 必须提前要一块连续的大地盘    | 随用随申请，哪里有空住哪里  | **链表**     |



### 4.ListNode和DoublyListNode到底是什么:

在之后我们很快就会见到ListNode和DoublyListNode,来说一下他们这个类到底是什么:

<span style="color:red">DoublyNodeList里面存储着val以及prev和next的DoublyNodeList对象,然后这里的prev和next是以地址存在的,在实际我们的遍历中,是通过next以及prev的地址然后得到对应的prev以及next的DoublyNodeList对象,然后里面存储着下下一个(相对于首个节点而言)的val以及prev和next的DoublyNodeList对象,这样在遍历的**感官**上让我们感觉好像拥有了prev以及next里的内容,但**实际上只根据当前节点根本不知道下一个节点里的实际内容,因为本质上是地址**,然后我们是通过地址访问相当于才跳转并刷新出下一个节点的内容,再不进入下一个节点之前,当前节点的next实际上存储的只是冷冰冰的地址</span>



### 单链表

#### 基本操作

我先写一个工具函数，用于创建一条单链表，方便后面的讲解：

```java
class ListNode {
    int val;
    ListNode next;
    ListNode(int x) { val = x; }
}

// 输入一个数组，转换为一条单链表
ListNode createLinkedList(int[] arr) {
    if (arr == null || arr.length == 0) {
        return null;
    }
    //不变的头
    ListNode head = new ListNode(arr[0]);
    //cur是一个随时往下走的指针
    ListNode cur = head;
    for (int i = 1; i < arr.length; i++) {
        cur.next = new ListNode(arr[i]);
        cur = cur.next;
    }
    return head;
}
```





对于上面整个自定义的工具类多说一下,我们不依赖createLinkedList手动就可以实现链表,createLinkedList把手动指定的环节 工具化:

```java
ListNode a = new ListNode(1);
ListNode b = new ListNode(2);
ListNode c = new ListNode(3);

a.next = b;
b.next = c;


ListNode pointer = a;
while(pointer!=null){
	System.out.println(pointer.val);
    pointer = pointer.next;
}

```

重点就在 ListNode里的next,彼此通过next连接,此时的初始值pointer存储的是数值"1"以及1下一个地址("2"的地址)

我们一步一步来看;
①ListNode a = new ListNode(1);

此时a只有数值val=1,还没有next的值,此时为null

②然后a.next = b;

此时a就有了数值val=1 以及下一个的地址(也就是数值为2名为b的**地址**)

b和c以及未来新加的都同理,所以当连起来后,只要知道a,尽管a只有b的值,从他开始他也会知道b,c乃至未来的d,e

然后pointer(header)在这里就是从第一个开始,然后一个遍历而已

知道这个就明白:`createLinkedList`是帮我们把手动a.next = b的这个过程通过遍历来实现了





#### 查/改

**单链表的遍历/查找/修改**

比方说，我想访问单链表的每一个节点，并打印其值，可以这样写：

```java
// 创建一条单链表
ListNode head = createLinkedList(new int[]{1, 2, 3, 4, 5});

// 遍历单链表
for (ListNode p = head; p != null; p = p.next) {
    System.out.println(p.val);
}
```

类似的，如果是要通过索引访问或修改链表中的某个节点，也只能用 for 循环从头结点开始往后找，直到找到索引对应的节点，然后进行访问或修改。

这个操作的最坏时间复杂度是 O(n)*O*(*n*)，其中 n*n* 是链表的长度。



#### 增

##### 1.在单链表头部插入新元素

我们会持有单链表的头结点，所以只需要将插入的节点接到头结点之前，并将新插入的节点作为头结点即可。

```java
// 创建一条单链表
ListNode head = createLinkedList(new int[]{1, 2, 3, 4, 5});

// 在单链表头部插入一个新节点 0
ListNode newNode = new ListNode(0);
//此时已经连上了
newNode.next = head;
//这一步的意义是让火车头知道谁是新的,不然每次要通过mewNode从头开始不利于规范
head = newNode;

// 现在链表变成了 0 -> 1 -> 2 -> 3 -> 4 -> 5
```

这个操作的时间复杂度是 $O(1)$。



##### 2.在单链表尾部插入新元素

直接看代码吧，很简单：

```java
// 创建一条单链表
ListNode head = createLinkedList(new int[]{1, 2, 3, 4, 5});

// 在单链表尾部插入一个新节点 6
ListNode p = head;
// 先走到链表的最后一个节点
while (p.next != null) {
    p = p.next;
}
// 现在 p 就是链表的最后一个节点
// 在 p 后面插入新节点
p.next = new ListNode(6);

// 现在链表变成了 1 -> 2 -> 3 -> 4 -> 5 -> 6
```

这个操作的时间复杂度是 O(n)，因为需要先遍历到链表尾部。当然，如果我们持有对链表尾节点的引用，那么在尾部插入新节点的操作就会变得非常简单，不用每次从头去遍历了。这个优化会在后面具体实现双链表时介绍。



##### 3.在单链表中间插入新元素

这个操作稍微有点复杂，我们还是要先找到要插入位置的前驱节点，然后操作前驱节点把新节点插入进去：

```java
// 创建一条单链表
ListNode head = createLinkedList(new int[]{1, 2, 3, 4, 5});

// 在第 3 个节点后面插入一个新节点 66
// 先要找到前驱节点，即第 3 个节点
ListNode p = head;
for (int i = 0; i < 2; i++) {
    p = p.next;
}
// 此时 p 指向第 3 个节点
// 组装新节点的后驱指针
ListNode newNode = new ListNode(66);
newNode.next = p.next;

// 插入新节点
p.next = newNode;

// 现在链表变成了 1 -> 2 -> 3 -> 66 -> 4 -> 5
```

这个操作的时间复杂度是 $O(n)$，因为需要先找到插入位置的前驱节点。



#### 删

##### 1.在单链表中删除一个节点

删除一个节点，首先要找到要被删除节点的前驱节点，然后把这个前驱节点的 `next` 指针指向被删除节点的下一个节点。这样就能把被删除节点从链表中摘除了。

```java
// 创建一条单链表
ListNode head = createLinkedList(new int[]{1, 2, 3, 4, 5});

// 删除第 4 个节点，要操作前驱节点
ListNode p = head;
for (int i = 0; i < 2; i++) {
    p = p.next;
}

// 此时 p 指向第 3 个节点，即要删除节点的前驱节点
// 把第 4 个节点从链表中摘除
p.next = p.next.next;

// 现在链表变成了 1 -> 2 -> 3 -> 5
```

这个操作的时间复杂度是 $O(n)$，因为需要先找到被删除节点的前驱节点。



##### 2.在单链表尾部删除元素

这个操作比较简单，找到倒数第二个节点，然后把它的 `next` 指针置为 null 就行了：

```java
// 创建一条单链表
ListNode head = createLinkedList(new int[]{1, 2, 3, 4, 5});

// 删除尾节点
ListNode p = head;
// 找到倒数第二个节点
while (p.next.next != null) {
    p = p.next;
}

// 此时 p 指向倒数第二个节点
// 把尾节点从链表中摘除
p.next = null;

// 现在链表变成了 1 -> 2 -> 3 -> 4
```

这个操作的时间复杂度是 $O(n)$，因为需要先遍历到倒数第二个节点。



##### 3.在单链表头部删除元素

这个操作比较简单，直接把 `head` 移动到下一个节点就行了，直接看代码吧：

```java
// 创建一条单链表
ListNode head = createLinkedList(new int[]{1, 2, 3, 4, 5});

// 删除头结点
head = head.next;

// 现在链表变成了 2 -> 3 -> 4 -> 5
```

这个操作的时间复杂度是 $O(1)$。

不过可能有读者疑惑，之前那个旧的头结点 `1` 的 next 指针依然指向着节点 `2`，这样会不会造成内存泄漏？

不会的，这个节点 `1` 指向其他的节点是没关系的，只要保证没有其他引用指向这个节点 `1`，它就能被垃圾回收器回收掉。

当然，如果你非要显式把节点 `1` 的 next 指针置为 null，这是个很好的习惯，在其他场景中可能可以避免指针错乱的潜在问题。

在下面这个可视化面板中，我显式地把待删除节点的 next 指针置为 null 了：

> 链表的增删查改操作确实比数组复杂。这是因为链表的节点不是紧挨着的，所以要增删一个节点，必须先找到它的前驱和后驱节点进行协同，然后才能通过指针操作把它插入或删除。
>
> 上面给出的代码还仅仅是最简单的例子，你会发现在头部、尾部、中间增删元素的代码都不一样。如果要实现一个真正可用的链表，你还要考虑到很多边界情况，比如链表可能为空、前后驱节点可能为空等，这些情况都得保证不出错。
>
> 而且，上面只是介绍了「单链表」，而我们下一章要实现的是「双链表」，双链表要同时维护前驱和后驱指针，指针操作会更复杂一些。
>
> 是不是已经不敢想了？不要怕，其实没你想的那么难，几个原因：
>
> 1、其实搞来搞去就那几个操作，等会儿带你动手实现链表 API 的时候，你亲自写一写，就会了。
>
> 2、复杂操作我都配了可视化面板，你可以结合面板中的代码和动画进行理解。
>
> 3、最重要的，我们会使用「**虚拟头结点**」技巧，把头、尾、中部的操作统一起来，同时还能避免处理头尾指针为空情况的边界情况。
>
> 虚拟节点技巧在 [单链表经典算法技巧](https://labuladong.online/zh/algo/essential-technique/linked-list-skills-summary/) 中也会经常运用，这里仅仅简单提一下，具体实现会在后面讲到。



### 双链表

#### 基本操作

先写一个工具函数，用于创建一条双链表，方便后面的讲解：

```java
class DoublyListNode {
    int val;
    DoublyListNode next, prev;
    DoublyListNode(int x) { val = x; }
}

DoublyListNode createDoublyLinkedList(int[] arr) {
    if (arr == null || arr.length == 0) {
        return null;
    }
    DoublyListNode head = new DoublyListNode(arr[0]);
    DoublyListNode cur = head;
    // for 循环迭代创建双链表
    for (int i = 1; i < arr.length; i++) {
        DoublyListNode newNode = new DoublyListNode(arr[i]);
        cur.next = newNode;
        newNode.prev = cur;
        cur = cur.next;
    }
    return head;
}
```



#### 查/改

> 双链表的遍历/查找/修改

对于双链表的遍历和查找，我们可以从头节点或尾节点开始，根据需要向前或向后遍历：

```java
// 创建一条双链表
DoublyListNode head = createDoublyLinkedList(new int[]{1, 2, 3, 4, 5});
DoublyListNode tail = null;

// 从头节点向后遍历双链表
for (DoublyListNode p = head; p != null; p = p.next) {
    System.out.println(p.val);
    tail = p;
}

// 从尾节点向前遍历双链表
for (DoublyListNode p = tail; p != null; p = p.prev) {
    System.out.println(p.val);
}
```

这个操作的最坏时间复杂度是 $O(n)$。访问或修改节点时，可以根据索引是靠近头部还是尾部，选择合适的方向遍历，这样可以一定程度上提高效率。



#### 增

##### 1.在双链表头部插入新元素

在双链表头部插入元素，需要调整新节点和原头节点的指针：

```java
// 创建一条双链表
DoublyListNode head = createDoublyLinkedList(new int[]{1, 2, 3, 4, 5});

// 在双链表头部插入新节点 0
DoublyListNode newHead = new DoublyListNode(0);
newHead.next = head;
head.prev = newHead;
head = newHead;
// 现在链表变成了 0 -> 1 -> 2 -> 3 -> 4 -> 5
```

这个操作的时间复杂度是 $O(1)$。



##### 2.在双链表尾部插入新元素

在双链表尾部插入元素时，如果我们持有尾节点的引用，这个操作会非常简单：

```java
// 创建一条双链表
DoublyListNode head = createDoublyLinkedList(new int[]{1, 2, 3, 4, 5});

DoublyListNode tail = head;
// 先走到链表的最后一个节点
while (tail.next != null) {
    tail = tail.next;
}

// 在双链表尾部插入新节点 6
DoublyListNode newNode = new DoublyListNode(6);
tail.next = newNode;
newNode.prev = tail;
// 更新尾节点引用
tail = newNode;

// 现在链表变成了 1 -> 2 -> 3 -> 4 -> 5 -> 6
```

这个操作的时间复杂度是 $O(n)$，因为需要先遍历到尾节点。如果持有尾节点引用，则是 $O(1)$。



##### 3.在双链表中间插入新元素

在双链表的指定位置插入新元素，需要调整前驱节点和后继节点的指针。

比如下面的例子，把元素 66 插入到索引 3（第 4 个节点）的位置：

```java
// 创建一条双链表
DoublyListNode head = createDoublyLinkedList(new int[]{1, 2, 3, 4, 5});

// 想要插入到索引 3（第 4 个节点）
// 需要操作索引 2（第 3 个节点）的指针
DoublyListNode p = head;
for (int i = 0; i < 2; i++) {
    p = p.next;
}

// 组装新节点
DoublyListNode newNode = new DoublyListNode(66);
newNode.next = p.next;
newNode.prev = p;

// 插入新节点
p.next.prev = newNode;
p.next = newNode;

// 现在链表变成了 1 -> 2 -> 3 -> 66 -> 4 -> 5
```

这个操作的时间复杂度是 $O(n)$，因为需要先找到插入位置。



#### 删

##### 1.在双链表中删除一个节点

在双链表中删除节点时，需要调整前驱节点和后继节点的指针来摘除目标节点：

```
// 创建一条双链表
DoublyListNode head = createDoublyLinkedList(new int[]{1, 2, 3, 4, 5});

// 删除第 4 个节点
// 先找到第 3 个节点
DoublyListNode p = head;
for (int i = 0; i < 2; i++) {
    p = p.next;
}

// 现在 p 指向第 3 个节点，我们它后面那个节点摘除出去
DoublyListNode toDelete = p.next;

// 把 toDelete 从链表中摘除
p.next = toDelete.next;
toDelete.next.prev = p;

// 把 toDelete 的前后指针都置为 null 是个好习惯（可选）
toDelete.next = null;
toDelete.prev = null;

// 现在链表变成了 1 -> 2 -> 3 -> 5
```

当然为了安全性向大厂看齐建议写成:

```java
DoublyListNode head = DoublyListNode.createDoublyLinkedList(new int[]{1,2,3,00,5,6,7});
DoublyListNode p = head;
for (int i = 0; i < 2; i++) {
     p = p.next;
}
DoublyListNode toDelete = p.next;
DoublyListNode boundTest = toDelete.next;

p.next = boundTest;
if (boundTest != null){
     toDelete.next.prev = p;
}


toDelete.next = null;
toDelete.prev = null;
toDelete.printList();
head.printList();
```

>  其中之所以`p.next = boundTest;`在if外面是因为有可能我们删除的是最后一个元素,而boundTest此时就是最后一个元素的next,所以当然有可能为null
>
> 然后是为什么要判断`boundTest != null`因为如果boundTest是null,那么就会触发`NullPointerException (NPE，空指针异常)。`而众所周知,`null` 在内存中代表“什么都没有”。,不能让“什么都没有”去执行动作。
>
> 然后手动写null会防止内存泄漏,是个好习惯



##### 2.在双链表头部删除元素

在双链表头部删除元素需要调整头节点的指针

```java
// 创建一条双链表
DoublyListNode head = createDoublyLinkedList(new int[]{1, 2, 3, 4, 5});

// 删除头结点
DoublyListNode toDelete = head;
head = head.next;
head.prev = null;

// 清理已删除节点的指针
toDelete.next = null;

// 现在链表变成了 2 -> 3 -> 4 -> 5
```

然后工业级开发:

```java
public int pollFirst() {
    // 1. 暂存当前头节点 (f 代表 first)
    final DoublyListNode f = head;
    if (f == null) return -1; // 判空

    int element = f.val;
    // 2. 暂存下一个节点
    final DoublyListNode nextNode = f.next;

    // 3. 斩断旧头的后路 (帮助 GC)
    f.next = null; 

    // 4. 移动 head 指针
    head = nextNode;

    // 5. 处理新头的路标
    if (nextNode == null) {
        // 说明删掉的是最后一个节点，tail 也要置空
        tail = null; 
    } else {
        // 斩断新头的前路，彻底孤立旧头
        nextNode.prev = null;
    }

    size--;
    return element;
}
```

以上的所有目的都是为了防止内存泄漏

这个操作的时间复杂度是 $O(1)$。



##### 3.在双链表尾部删除元素

在单链表中，由于缺乏前驱指针，所以删除尾节点时需要遍历到倒数第二个节点，操作它的 `next` 指针，才能把尾节点摘除出去。

但在双链表中，由于每个节点都存储了前驱节点的指针，所以我们可以直接操作尾节点，把它自己从链表中摘除

```
// 创建一条双链表
DoublyListNode head = createDoublyLinkedList(new int[]{1, 2, 3, 4, 5});

// 删除尾节点
DoublyListNode p = head;
// 找到尾结点
while (p.next != null) {
    p = p.next;
}

// 现在 p 指向尾节点
// 把尾节点从链表中摘除
p.prev.next = null;

// 把被删结点的指针都断开是个好习惯（可选）
p.prev = null;

// 现在链表变成了 1 -> 2 -> 3 -> 4
```

这个操作的时间复杂度是 $O(n)$，因为需要先遍历到尾节点。如果持有尾节点引用，则是 $O(1)。$
